/*
======================================================================

RSS Power Tool Source Code
Copyright (C) 2013 Gregory Naughton

This file is part of RSS Power Tool

RSS Power Tool is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

RSS Power Tool is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with RSS Power Tool  If not, see <http://www.gnu.org/licenses/>.

======================================================================
*/

// main.cpp

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <errno.h>
#ifdef __APPLE__
#include <signal.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>

#include "tinyxml2.h"
using namespace tinyxml2;

extern "C" 
{
#include <curl/curl.h>
} // extern "C"

#include "datastruct.h"
#include "misc.h"
#include "dba_sqlite.h"
#include "tokenizer.h"
#include "unicode.h"
#include "sha1.h"
#include "quicksort.h"
#include "curseview.h"
#include "item_result.h"


#define RSS_OPML_TITLE_STRING       "RSS Command Line Feed Reader - Feeds Export"
#define RSS_VERSION_NUMBER          "0.17"
#define BAD_DATE_STRING             " "         /* ' ', '!', or '#' will sort older than "2013-03-..." */
#define RSS_GENERATOR               "Generated by RSS Powertool"

// globals
int myargc;
char **myargv;
basicString_t exename;
static const char * db_name = "rssapp.db";
basicString_t db_path;
basicString_t db_fullpath; // db_path/db_name
basicString_t config_dir;
basicString_t config_path; // '<config_dir>/config'
basicString_t db_fullpath_explicit; // overrides regular detection. exit returning error if not valid db 
DBSqlite DBA; // db handle
basicString_t username;
basicString_t system_name;
stringbuffer_t cmd_args;
const unsigned int rss_list_title_maxlen = 36;
basicString_t download_path;
int text_field_max_len = 0;
int curl_timeout_sec = 20;
                                // "libcurl-agent/1.0" 
basicString_t curl_user_agent = "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.A.B.C Safari/525.13";

bool enable_progress_meter = false;
const unsigned int rss_show_description_len = 38;
const unsigned int rss_show_ftitle_len = 28;
unsigned int max_reports_save = 25;
bool config_strip_html_on = true;
bool config_use_pager = true;
bool force_pager = false; // activated by --pager flag to cause use no matter which command is being run
int pipe_fd[2] = {-1,-1};
pid_t pager_pid = 0;
int term_lines = 0;
int term_cols = 0;
const char * podcast_detection_types[] = { ".mp3", ".m4a", ".m4b", ".m4v", ".mp4", ".mov", ".ogg", ".aac", 0 };
bool empty_date_set_to_current_time = true;
unsigned int update_title_len = 32;
bool enable_dashed_line = true;
char dashed_line_char = 0;
int feed_timeouts_limit = 5;

basicString_t pager_path; 
basicString_t browser_path;
basicString_t text_browser_path;
basicString_t instapaper_username;
basicString_t instapaper_password;
int slideshow_speed = 5;

const char * ordinals[] = {"0th","1st","2nd","3rd","4th","5th","6th","7th","8th","9th",0};





struct globochem_s {
    const char * opt;
    const char * help;
} global_options[] = {
//{ "-d",                 "set download path" },
{ "-c",                 "set config path" },
{ "-db",                "set database path" },
{ "-h",                 "show help" },
{ "--help",             "show help" },
{ "--version",          "show version" },
{ "--no-strip-html",    "disable html parsing" },
{ "--no-pager",         "disable pager" },
{ "--pager",            "enable pager. Force pager to on." },
{ 0, 0 }
};

enum RSS_COMMAND_T 
{
    CMD_NULL = 0,
    CMD_IMPORT = 11,
    CMD_EXPORT,
    CMD_LIST,
    CMD_FEEDS,
    CMD_ADD,
    CMD_DEL,
    CMD_TAG,
    CMD_RM,
    CMD_EDIT,
    CMD_UPDATE,
    CMD_SHOW,
    CMD_SELECT,
    CMD_DOWNLOAD,
    CMD_SLIDESHOW,
    CMD_FETCH,
    CMD_CONFIG,
    CMD_SEARCH,
    CMD_VIEW,
    CMD_DUMP,
    CMD_POST,
    CMD_REPORT,
    CMD_DISABLE,
    CMD_ENABLE,
    CMD_MARK,
    CMD_TEST,
    CMD_POD,
    CMD_VIS,
    CMD_VERSION,
    CMD_PRIORITY
};

struct Cmd_s
{
    RSS_COMMAND_T code;
    const char * keyword;
} command_list[] = 
{
{ CMD_IMPORT, "import" },
{ CMD_EXPORT, "export" },
{ CMD_LIST, "list" },
{ CMD_FEEDS, "feeds" },
{ CMD_ADD, "add" },
{ CMD_RM, "rm" },
{ CMD_VIEW, "view" },
{ CMD_DEL, "del" },
{ CMD_EDIT, "edit" },
{ CMD_UPDATE, "update" },
{ CMD_SHOW, "show" },
{ CMD_REPORT, "report" },
{ CMD_ENABLE, "enable" },
{ CMD_VERSION, "version" },
{ CMD_DISABLE, "disable" },
{ CMD_SEARCH, "search" },
{ CMD_DUMP, "dump" },
{ CMD_POD, "pod" },
{ CMD_VIS, "vis" },
{ CMD_PRIORITY, "priority" },
/* ---------------- */
{ CMD_TAG, "tag" },
{ CMD_SELECT, "select" },
{ CMD_DOWNLOAD, "download" },
{ CMD_SLIDESHOW, "slideshow" },
{ CMD_CONFIG, "config" },
/* ---------------- */
{ CMD_FETCH, "fetch" },
{ CMD_POST, "post" },
{ CMD_MARK, "mark" },
{ CMD_TEST, "test" },
{ CMD_NULL, 0 }
};

RSS_COMMAND_T run_code = CMD_NULL;

#ifdef __APPLE__
const char * get_sysname() {
    return "Darwin";
}
#elif defined(__linux)
const char * get_sysname() {
    return "Linux";
}
#elif defined(__unix)
const char * get_sysname() {
    return "Unix";
}
#elif defined(_WIN32) || defined(_WIN64)
const char * get_sysname() {
    return "Windows";
}
#else
const char * get_sysname() {
    return "Notsure";
}
#endif

#ifdef __linux
const char * get_username() {
    return cuserid(0); // is process owner better than who logged in?
}
#else 
const char * get_username() {
    return getlogin();
}
#endif

static void print_usage()
{
    printf( "usage: %s [global options] [command] [arg1[arg2][...]]\n\nglobal options:\n", exename.str );

    struct globochem_s * p = global_options;
    do
    {
        printf( "   %-20s%s\n", p->opt, p->help );
    } 
    while ( (++p)->opt );

    printf( "\ncommands:\n" \
"   priority    print out feed priority of all the feeds\n" \
"   import      import a group of feeds from xml/opml file\n" \
"   export      generate opml output of your stored feed database\n" \
"   list        list the feeds you have stored\n" \
"   show        show the items of a feed\n" \
"   update      update your feeds\n" \
"   add         add a single feed, by url\n" \
"   edit        edit a feed's attributes\n" \
"   view        view a feed's attributes\n" \
"   report      print most recent update report\n" \
"   disable     disable updating for a feed\n" \
"   enable      enable updating for a feed, and reset timeouts\n" \
"   rm          remove a feed\n" \
"   dump        fetch and dump a specific feed as its raw xml\n" \
"   search      search for stuff\n" \
"   vis         visual mode\n\n" \
"   see: '%s [command] -h' for help with a specific command\n", exename.str );
}
/*
"   download\n" \
"   config\n" \
"   tag\n" \
*/


/*
- type A) 2012-10-22T08:50:49+00:00
- type B) Sun, 27 Feb 2011 11:46:14 -0500
- type C) Tue, 22 Mar 2013 14:37:01 GMT
- type D) Sat, 9 Mar 2013 12:00:00 -0400
- type E) Thu, 29 September 2011 07:02:46 GMT 
          0123456789012345678
              |  |  ||
the obvious way to tell the difference is to check the spaces.
Also, just keep pubDate, and insert fixed_date in a separate field
*/
static const char * get_sqldate( basicString_t& base )
{
    static basicString_t out;
    out.erase();

    if ( base.length() == 0 )
        return BAD_DATE_STRING;

    basicString_t tmp;
    basicString_t target = base.trim();

    long long start = reinterpret_cast<long long>( target.str );
    const char * p = target.strstr( "T" );
    long long Apoint = reinterpret_cast<long long>(p) - start;
    p = target.strstr( " " );
    long long Bpoint = reinterpret_cast<long long>(p) - start;


    // type A
    if ( Apoint == 10 && Bpoint != 4 && target.length() >= 19 ) {
        char * c = const_cast<char*>(target.str + 10);
        *c = ' '; // Make it mysql format. Don't worry about the trailing, mysql will truncate it
        out.strncpy( target.str, 19 ); 
    } 

    // probably already sql-style
    else if ( base.length() == strlen( "2013-03-13 12:30:00" ) ) 
    {
        out = base;
    }

    // type B/C
    else if ( Bpoint == 4 ) 
    {
        if ( strlen( target.str ) < strlen( "Sat, 9 Mar 2013 12:00:00" ) )
            error( "bad dates Indiana Jones\n" );
        // DAY
        const char * day = target.str + 5; // this one ought to be consistent;
        int day_len = ( *(day+1) < '0' || *(day+1) > '9' ) ? 1 : 2;
        
        // MON
        int month_offset = 5 + day_len + 1;

        // detect month: get number from stupid text
        const char *months[] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec",0};
        int i = 0;
        unsigned int mon_len = 3;
        do
        {
            if ( target.strstr( months[i++] ) == target.str+month_offset ) {
                const char * x = target.str + month_offset + mon_len;
                // longest long-name month:  September
                //                              |
                while ( *x++ != ' ' && mon_len < strlen("September") )
                    ++mon_len;
                break;
            }
        }
        while ( months[i] ); 

        
        if ( i == 13 ) // aint typeB neither
            return 0;

        // definitely type B/C
        // Sat, 9 Mar 2013 12:00:00 -0400 

        int year_offset = 5 + day_len + 1 + mon_len + 1;

        // point to year
        p = target.str + year_offset; 
        out.append( p, 4 ); // year YYYY

        // -
        out.append( "-",1);
        
        // month digits: always 2chars w/ leading 0
        tmp.sprintf( "%02d-", i );
        out.append( tmp );

        // day
        if ( 1 == day_len ) 
            out.append( "0" ); // leading zero
        out.append( day, day_len );

        // ' '
        out.append( " " );

        // time
        p = target.str + 5 + day_len + 1 + mon_len + 1 + 5;
        out.append( p, 8 );
    }

    if ( out.length() != strlen( "yyyy-mm-dd hh:mm:ss" ) ) {
#ifdef _DEBUG
        warning( "get_sqldate irregular date, culprit: \"%s\"\n", base.str );
        fflush(stdout);
        fflush(stderr);
#endif
        return 0; // this will cause it to give us sqldate_now()
        //return BAD_DATE_STRING;
    }
    
    //Assert( strlen(out.str) == strlen( "yyyy-mm-dd hh-mm-ss" ) && "Harold, The fucking Sql Date thing fucking broke again." );

    return out.str;
}

const char * sqldate_now()
{
    static basicString_t out;
    struct tm s;
    time_t epoch = time(0);
    localtime_r( &epoch, &s );
    out.sprintf( "%d-%02d-%02d %02d:%02d:%02d", 1900+s.tm_year, 1+s.tm_mon, s.tm_mday, s.tm_hour, s.tm_min, s.tm_sec );
    return out.str;
}

const char * javascript_now()
{
    static basicString_t out;
    time_t epoch = time(0);
    out.sprintf( "%lu", epoch );
    out += "000";
    return out.str;
} 

// <dc:date>2013-04-25T07:00:00+00:00</dc:date>
const char * make_dcdate( const char * sql )
{
    static basicString_t out;
    out.erase();
    if ( !sql || !*sql ) {
        return out.str;
    }
    out = sql;
    if ( out.length() < 11 )
        return out.str;
    out.str[10] = 'T';
    out += "+00:00";
    return out.str;
}
const char * unmake_dcdate( const char * sql )
{
    static basicString_t out;
    out.erase();
    if ( !sql || !*sql ) {
        return out.str;
    }
    out = sql;
    if ( out.length() < 11 )
        return out.str;
    out.str[10] = ' ';
    out.strncpy( out.str, strlen( "xxxx-xx-xx xx:xx:xx" ) ); 
    return out.str;
}

// turns "yyyy-mm-dd hh:mm:ss" --> "mm/dd/yy" & tries to remove leading 0s
basicString_t squish_sqldate_us( basicString_t& date )
{
    if ( !date.length() || !date.str || !*date.str )
        return basicString_t(" ");

    // yy-mm-dd
    basicString_t o = date.substr(2,8);

    char * s = o.str;
    char yr[3] = {0,0,0};
    strncpy( yr, s, 2 ); // save year

    memmove( s, &s[3], 5 ); // mm-dd
    s[5] = 0;

    s[2] =  '/'; // mm/dd

    if ( s[0] == '0' ) {
        memmove( &s[0], &s[1], 4 ); // m/dd
        s[4] = 0;
        if ( s[2] == '0' )
            memmove( &s[2], &s[3], 2 ); // m/d
    } else {
        if ( s[3] == '0' ) {
            memmove( &s[3], &s[4], 1 ); // mm/d
            s[4] = 0;
        }
    }

    o.len = strlen( o.str );
    o += '/';
    o += yr;
    return o;
}

void draw_dashed_line( char c ='-', int explen =0 )
{
    if ( !enable_dashed_line )
        return;
    if ( dashed_line_char )
        c = dashed_line_char;

    // ensure sane size
    int size = explen ? explen : 0 == term_cols ? 80 : term_cols;
    basicString_t line;
    line.setMem( size + 1 );
    for ( int i = 0; i < size; i++ )
        line.str[i] = c;
    printf( "%s\n", line.str );
    fflush(stdout);
}

// takes string of number, comma & hyphen and constructs an array of int out of it. 
void translate_str_range( const char * str, buffer_t<unsigned int>& buf )
{
    char * p = const_cast<char*>( str );
    
    // must start with a number,',',' ', or can even start with '-' but it will be ignored
    // spaces are skipped 

    int dig = 0;
    int next;
    int range_start = -1;

    do 
    {
        if ( !*p )
            break;

        if ( *p <= '9' && *p >= '0' )
        {
            dig = 0;
            while ( *p && *p <= '9' && *p >= '0' )
            {
                next = *p++ - '0';
                dig = dig*10+next;
            }

            if ( -1 != range_start )
            {
                for ( int i = range_start+1/*already added range_start*/; i<= dig; i++ )
                {
                    buf.add( (unsigned)i );
                }
                range_start = -1;
            }
            else if ( dig ) {
                buf.add( (unsigned)dig );
            }
        }
        else if ( *p == ' ' ) 
        {
            while ( *p && *p == ' ' ) 
                ++p;
        }
        else if ( *p == '-' ) // range
        {
            // case that '-10' is first part of string
            if ( 0 != dig )
                range_start = dig;           
            ++p; // move past the '-'
        }
        else if ( *p == ',' ) // next one
        {
            ++p;
        }
        else // bad char
        {
            break;
        }
    }
    while(1);
}

// try to get, in this order:
//  - single integer, eg. 30
//  - group of intengers, eg. 1-3,6,7-9
//  - match string (usually made-up of mostly A-Z). Must start with [A-Za-z]
//  - empty
// detects which it is, gets an integer list of feed ids, without checking bounds, and formats
//  into a SQL WHERE condition
//  - will return a reference to an empty string, if nothing pans out
basicString_t &  translate_unknown_args( const char * arg, const char * matching_col ="feed.id", bool want =true )
{
    // if string start with 0-9 it is probably a number or range
    // if string contains '-' or ',' it is probably a range
    // if it does not contain '-' or ',' it is definitely a single digit
    // if it starts with [^0-9-,], it is definitely a match string

    static basicString_t out;
    out.clear();
    basicString_t buf;

    if ( !arg || !*arg ) {
        return out;
    }

    basicString_t arg_trimmer( arg );
    arg_trimmer.trim();
    arg = arg_trimmer.str;

    buffer_t<unsigned int> ids;

    // is a match string
    buf = "item.id";
    // dont do for item.id
    if ( buf != matching_col && (*arg < '0' || *arg > '9') && *arg != ',' && *arg != '-' )
    {
        DBResult * res = DBA( buf.sprintf( "select id from feed where feed.title like '%%%s%%';", arg ).str );
        if ( !res )
            return out;
        DBRow * row;
        while ( (row = res->NextRow()) )
        {
            DBValue * v = row->FindByName( "id" );
            if ( v && v->getInt() )
                ids.add( (unsigned)v->getInt() );
        }
    }
    else
    { 
        translate_str_range( arg, ids );
    }

    //
    // turn ids into SQL where clause
    //

    if ( 0 == ids.length() )
        return out;

    // sort 
    quicksort<unsigned int>( ids.data, ids.length() );


    // range sets
    unsigned int range_counter = 0;
    cppbuffer_t<uiPair_t> ranges; 

    // single matches 
    buffer_t<unsigned int> single_matches;


    for ( unsigned int i = 0; i < ids.length(); i++ )
    {
        // only one left
        if ( i+1 == ids.length() )
            single_matches.add( ids.data[i] );
        else
        {

            // look
            if ( ids.data[i+1] == ids.data[i]+1 ) // range detected
            {
                ranges[range_counter].start = ids.data[i];

                while ( i < ids.length() - 1 )
                {
                    if ( ids.data[i+1] == ids.data[i]+1 ) 
                        ++i;
                    else
                        break;
                } 

                ranges[range_counter].stop = ids.data[i];
                ++range_counter;
            } 
            else
                single_matches.add( ids.data[i] );
        }
    }

    basicString_t med;
    out = "(";

    // SINGLE MATCHES
    // compose in buf because we have to strncpy at the end
    if ( single_matches.length() > 0 ) {
        buf = "(";
        for ( unsigned int i = 0; i < single_matches.length(); i++ )
        {
            buf.append( med.sprintf( "%s%s%d %s ", matching_col, want?"=":"!=", single_matches[i], want?"or":"and" ).str );
        }
        med.strncpy( buf.str, buf.length() - 4 );
        out += med += ")";
    }

    // RANGES
    if ( range_counter > 0 )
    {
        for ( unsigned int i = 0; i < range_counter; i++ ) {
            if ( out.length() > 1 )
                out += " or ";
            out.append( buf.sprintf( "(%s >= %d and %s <= %d)", matching_col, ranges[i].start, matching_col, ranges[i].stop ).str );
        }
    }
    
    return out += ")";
}


static char * trim_white_space( char * str )
{   
    char * p = str;
    while ( *p != '\0' && (*p == ' '||*p == '\t') )
        ++p;
    char * e = str;
    while ( *e != '\0' )
        ++e;

    int set = 0;
    do
    {  
        long long end = reinterpret_cast<long long>(e-1);
        long long beg = reinterpret_cast<long long>(p);
        if ( end <= beg )
            break;
        if ( *(e-1) == ' ' )
            --e, ++set;
        else
            break;
    } while(1);

    if ( set ) {
        *e = '\0';
    }

    return p;
}

static char * get_input_raw()
{
    #define INPUT_SZ 1000
    static char buf[INPUT_SZ];
    int i = 0;
    do {
        char c = getc(stdin);
        buf[i++] = c;
        if ( c == '\n' ) {
            buf[--i] = 0;
            break;
        }
        if ( i >= INPUT_SZ )
            break;
    }
    while (1);
    buf[INPUT_SZ-1] = 0; 
    return buf;
}

static const char * get_input()
{
    char * ret = get_input_raw();
    return trim_white_space( ret );
}

const char * prompt( const char * question, int yes_no =1, int def_yes =0 )
{
    const char * d_yes = "[Y/n]?";
    const char * d_no = "[y/N]?";
    static basicString_t out;
    out.erase();

    if ( yes_no ) {
        printf( "%s %s ", question, def_yes ? d_yes : d_no );
    } else {
        printf( "%s ", question );
    }

    const char * ans = get_input();
    
    if ( yes_no ) {
        if ( strcmp( ans, "y" ) == 0 || strcmp( ans, "Y" ) == 0 ) {
            out.set( d_yes );
            return out.str;
        } else {
            return 0;
        }
    }

    out = ans;
    return out.str;
}



struct Feed_t
{
    int id;
    basicString_t title;
    basicString_t xmlUrl;
    basicString_t htmlUrl;
    basicString_t description;
    basicString_t type;
    basicString_t priority;
    int disabled;
    int timeouts;
    void clear() {
        id = -1;
        title = "";
        xmlUrl = "";
        htmlUrl = "";
        description = "";
        type = "";
        priority = "";
        disabled = timeouts = 0;
    } 
    Feed_t() : id(-1), disabled(0), timeouts(0)
    { }
};

struct Item_t
{
    int feed_id;
    basicString_t title;
    basicString_t description;
    basicString_t pubDate;
    basicString_t sqldate;
    basicString_t media_url;
    basicString_t item_url;
    basicString_t content;
    basicString_t author;
    basicString_t hash;

    void clear() { 
        feed_id = 0;
        title.set( "" );
        description.set( "" );
        pubDate.set( "" );
        sqldate.erase();
        media_url.set( "" );
        item_url.set( "" );
        content.erase();
        author.erase();
        hash.erase();
    }

    void trim() {
        title.trim();
        description.trim();
        pubDate.trim();
        sqldate.trim();
        media_url.trim();
        item_url.trim();
        content.trim();
        author.trim();
    }


    // generate and store internally
    void gen_hash() {
        this->hash = this->get_hash();
    }

private:
    // *see have_item() for notes on exact hash heuristic
    const char * get_hash()
    {
        basicString_t buf;

        int x_count = (sqldate.length()!=0u) + (title.length()!=0u) + (media_url.length()!=0u||item_url.length()!=0u);
        switch ( x_count ) 
        {
        case 3: 
            buf = sqldate.substr(0,10).str; 
            buf += title;
            buf += media_url;
            buf += item_url;
            break;
        case 2:
            buf.sprintf( "%d", feed_id );
            if ( sqldate.length() )
                buf += sqldate.substr(0,10).str; 
            if ( title.length() )
                buf += title;
            if ( media_url.length() )
                buf += media_url;
            if ( item_url.length() )
                buf += item_url;
            break;
        default:
            return 0; // no hash, unique item
            break;
        }

        return SHA1_BlockSumPrintable( buf.str, buf.length() ) ;
    }
};

struct FeedBuffer_t : public cppbuffer_t<Feed_t*>
{
    FeedBuffer_t() 
    { }

    void startNew() { 
        push_back( new Feed_t );
    }

    void setTitle( const char * title ) {
        if ( count() == 0 )
            push_back( new Feed_t ); 
        (*this)[ this->count()-1 ]->title = title;
    }

    void setXmlUrl( const char *xml ) {
        if ( count() == 0 )
            push_back( new Feed_t ); 
        (*this)[ this->count()-1 ]->xmlUrl = xml;
    }

    void setHtmlUrl( const char *url ) {
        if ( count() == 0 )
            push_back( new Feed_t ); 
        (*this)[ this->count()-1 ]->htmlUrl = url;
    }

    void setDescription( const char * des ) {
        if ( count() == 0 )
            push_back( new Feed_t ); 
        (*this)[ this->count()-1 ]->description = des;
    }

    void setType( const char * _type ) {
        if ( count() == 0 )
            push_back( new Feed_t ); 
        (*this)[ this->count()-1 ]->type = _type;
    }

    void setDisabled( const char * _type ) {
        if ( count() == 0 )
            push_back( new Feed_t ); 
        (*this)[ this->count()-1 ]->disabled = atoi(_type);
    }

    ~FeedBuffer_t() {
        for ( unsigned int i = 0; i < count(); i++ ) {
            delete (*this)[i];
        }
    }
};

// turns out I have been writing too much bash scripting. 
// One does not need to worry about system escape characters using regular fopen()
basicString_t * escape_string( const char * str, basicString_t * reuse=0 ) 
{
    static const char esc[] = { '`','$','\\','/','\'',']','[','(',')','{','}',' ',',','!','@','#','%','^','&','*',':',';','?','"','~',0};

    basicString_t * n = reuse ? reuse : new basicString_t;

    n->set( str );
    n->append( str, n->length() ); // double the length
    n->erase();
    int i = 0, e, do_e;
    char c;
    char app[4];
    while ( (c = str[i++]) )
    {
        do_e = 0;
        e = 0;
        do
        {
            if ( esc[e] == c ) {
                do_e = 1;
                break;
            }
        }
        while ( esc[++e] ) ;

        if ( do_e )
        {
            app[0] = '\\';
            app[1] = c;
            n->append( app, 2 );
        } else {
            n->append( &c, 1 );
        }
    }

    return n;
}


// returns pointer to it if it exists
const char ** check_cmdline( const char *parm )
{
    int i;
    for ( i = 1; i < myargc; i++ ) {
        if ( ! strcmp( parm, myargv[i] ) ) {
            return (const char **) &myargv[i];
        }
    }
    return (const char **)0;
}

// get argument to a particular cmd switch, if any...
const char * cmdline_arg( const char * cmd )
{
    int i;
    for ( i = 1; i < myargc; i++ ) {
        if ( ! strcmp( cmd, myargv[i] ) ) {
            if ( (i+1) < myargc )
            {  
                // check for leading '-', if none, return it
                const char * p = myargv[ i + 1 ];
                if ( *p != '-' )
                    return p;
                else
                    return (const char *)0;
            }
        }
    }
    return (const char *)0;
}

// wrapper for check_cmdline & cmdline_arg
const char * check_cmdline_return_arg( const char * parm ) 
{
    if ( check_cmdline( parm ) ) {
        const char * A = cmdline_arg( parm );
        if ( A ) 
            return A;
    }
    return 0;
}

RSS_COMMAND_T is_command( const char *frag )
{
    register int i = 0;
    do 
    {
        if ( strcmp( command_list[i].keyword, frag ) == 0 )
        {
            return command_list[i].code;
        }
    } 
    while( command_list[++i].code );

    return CMD_NULL;
}

const char * is_global_flag( const char * maybe )
{
    register int i = 0;
    do 
    {
        if ( strcmp( global_options[i].opt, maybe ) == 0 )
        {
            return maybe;
        }
    } 
    while( global_options[++i].opt );

    return 0;
}

// format: exename [options] [command] [arg1[arg2][...]] 
static void parse_arguments( int argc, char ** argv )
{
    myargc = argc;
    myargv = argv;  

    // get exename
    const char * p = strrchr( argv[0], '/' );
    exename = p ? p + 1 : argv[0];

    // if argc == 1: print_usage()
    if ( myargc == 1 ) {
        print_usage();
        exit( EXIT_SUCCESS );
    }

    /* we check arg2..N until:
        - we run out of args
        - one of the args does not match available global commands
    
        once we hit a valid command, we know that global args are done.
        - if we hit the end or if one of the flags doesn't match available global flags, print_usage and exit
    */

    RSS_COMMAND_T code = CMD_NULL;

    for ( int i = 1; i < argc; i++ ) {
        if ( is_global_flag( argv[i] ) ) {
            if ( strcmp( argv[i], "-h" ) == 0 || strcmp( argv[i], "--help" ) == 0 ) {
                print_usage();
                exit( EXIT_SUCCESS );
            }
            if ( strcmp( argv[i], "--version" ) == 0 ) {
                printf( "%s\n", RSS_VERSION_NUMBER );
                exit( EXIT_SUCCESS );
            }
            if ( strcmp( argv[i], "--no-strip-html" ) == 0 ) {
                config_strip_html_on = false;
            }
            if ( strcmp( argv[i], "--no-pager" ) == 0 ) {
                config_use_pager = false;
            }
            if ( strcmp( argv[i], "--pager" ) == 0 ) {
                force_pager = true;
                config_use_pager = true;
            }

            if ( strcmp( argv[i], "-db" ) == 0 ) {
                const char * db_path_arg = check_cmdline_return_arg( "-db" );
                if ( db_path_arg == 0 ) {
                    error( "please provide db." );
                }
                db_fullpath_explicit = file_exists( db_path_arg );
                if ( !db_fullpath_explicit.length() )
                    error( "explicit db: \"%s\" doesn't exist or is not readable\n", db_path_arg );
                printf( "using db path: \"%s\"\n", db_fullpath_explicit.str );
                ++i;
            } else if ( strcmp( argv[i], "-c" ) == 0 ) {
                config_path = check_cmdline_return_arg( "-c" );
                if ( config_path.length() == 0 ) {
                    error( "please provide config path." );
                }
                printf( "using config: \"%s\"\n", config_path.str );
                ++i;
            } else if ( strcmp( argv[i], "-d" ) == 0 ) { 
                download_path = check_cmdline_return_arg( "-d" );
                if ( download_path.length() == 0 ) {
                    error( "please provide download path." );
                }
                printf( "using download_path: \"%s\"\n", download_path.str );
                ++i;
            }
        } 
        else if ( (code=is_command( argv[i] )) ) 
        {
            run_code = code;

            // get remaining args as command args
            for ( int k = i+1; k < argc; k++ ) {
                cmd_args.push_back( myargv[k] );
            }
            break;
        } else {
            print_usage();
            exit( EXIT_SUCCESS );
        }
    }
}




int CreateDB()
{
    const char * db_calls[] = { 
        "CREATE TABLE feed (                    \
        id INTEGER PRIMARY KEY NOT NULL,        \
        title TEXT,                             \
        xmlUrl TEXT,                            \
        htmlUrl TEXT,                           \
        description TEXT,                       \
        last_updated DATETIME,                  \
        last_downloaded DATETIME,               \
        type TEXT,                              \
        timeouts INTEGER default 0,             \
        errmsg TEXT,                            \
        disabled char(1) default 0,             \
        priority INTEGER default 5,             \
        time_reading REAL default 0.0           \
        );",   

        "CREATE TABLE item (                    \
        id INTEGER PRIMARY KEY NOT NULL,        \
        title TEXT,                             \
        description TEXT,                       \
        pubDate TEXT,                           \
        sqldate TEXT,                           \
        media_url TEXT,                         \
        item_url TEXT,                          \
        content   TEXT,                         \
        author    TEXT,                         \
        hash      TEXT,                         \
        tag TEXT,                               \
        deleted char(1) default 0               \
        );",

        /* item-feed relationship is 1-to-many. Each item is atomic. It may have 1-N feeds. */
        "CREATE TABLE item_feeds (              \
        id INTEGER PRIMARY KEY NOT NULL,        \
        item_id INTEGER,                        \
        feed_id INTEGER                         \
        );",
    
        /* save reports of recent updates to facilitate easy viewing of just those items */
        "CREATE TABLE reports(                  \
        id INTEGER PRIMARY KEY NOT NULL,        \
        update_time DATETIME,                   \
        report TEXT,                            \
        item_ids TEXT                           \
        );",

        "CREATE TABLE saved_links(              \
        id INTEGER PRIMARY KEY NOT NULL,        \
        timestamp DATETIME,                     \
        title TEXT,                             \
        media_url TEXT,                         \
        item_url TEXT,                          \
        feed_id INTENGER,                       \
        item_id INTENGER,                       \
        downloaded char(1) default 0            \
        );",

        "CREATE TABLE keyvalue(                 \
        id INTEGER PRIMARY KEY NOT NULL,        \
        key TEXT,                               \
        value TEXT,                             \
        comment TEXT                            \
        );",

        "insert into keyvalue values(NULL,'numdeleted','0','int; item deleted count. vacuum resets count.');",
        "insert into keyvalue values(NULL,'bookmarks_changed','0','intbool; set to 1 when bookmark is added or deleted so it knows theres been a change. When bookmarks are resaved it sets to 0.');",

        0 };

    //
    // tokenize the db calls and concatenate to remove whitespace
    //
    int call_num = 0;
    basicString_t buf;
    while ( db_calls[ call_num ] )
    {
        const char * db_cmd = db_calls[ call_num ];

        // initialize to alloc enough memory, but wipe it 
        buf.set( db_cmd );
        unsigned int before_len = buf.length();
        buf.erase();

        // tokenize the command, then append them one-at-a-time
        Tokenizer_t tok( db_cmd, before_len );
        tok.tokenize();
        Token_t * t = tok.getHead();
        while ( t ) {
            buf.append( t->str, t->length() );
            buf.append( " ", 1 );
            t = t->next;
        }

        // call w/ the concatenated string
        DBA( buf.str );

        ++call_num;
    }
    
    return 0;
}

static int try_setup_explicit_db()
{
    if ( !db_fullpath_explicit.str || !*db_fullpath_explicit.str )
        return 0;

#if 0
    // if file doesn't exist, exit with error
    const char * p = file_exists( db_fullpath_explicit.str );
    if ( !p ) 
        error( "explicit db: \"%s\" doesn't exist or is not readable\n", db_fullpath_explicit.str );
#endif

    // if file exists, but schema is bad, exit with error, report version differences
    // ...TODO

    // all good, set db_path
    db_path = db_fullpath_explicit;

    return 1;
}

static void write_default_config()
{
    // download_path, defaults to: "/%/username/Downloads"

    basicString_t bar( "###########################################################" );
    basicString_t conf(bar); 
    conf += "\n#\n# Configuration for RSS Power Tool\n#\n# Uncomment options below to set to user-defined values\n#\n";
    conf += bar + "\n\n";

    // database
    conf += "# set a custom database; full path to file\n# db_fullpath = ~/.rss/rssapp.db\n\n";

    // instapaper
    conf += "# Instapaper settings for quicksaving links in the Instapaper bookmarklet\n# instapaper_username = <username>\n# instapaper_password = <password>\n\n";

    // pager
    conf += "# preferred pager \n# pager = /usr/bin/less\n\n";

    // browser
    conf += "# preferred web browser \n# browser = \n\n";

    // text browser
    conf += "# preferred text browser; usually lynx or links \n# text_browser = /usr/bin/lynx \n\n";

    // curl
    conf += "# Curl timeout seconds (default 20) \n# curl_timeout_sec = 20\n\n";

    // speed
    conf += "# Default slideshow speed (seconds)\n# slideshow_speed = 5\n\n";

    // num timeouts
    conf += "# Number of allowed timeouts before feed is automatically disabled\n# feed_timeouts_limit = 5 \n\n";

    // sync paths
    conf += "# if this is uncommented and path set, rss will try to sync bookmarks to a feed\n"
"# generated from your bookmarks. The default filename is: bookmarks.xml\n"
"# If you already have this file, rename to bookmarks.xml and place in the path.\n"
"# If you don't want to rename it, uncomment bookmarks_filename and set it there.\n"
"# Setting to config_path this will check the current configuration path\n"
"# for the bookmarks.xml.  If the path is set, but found empty, a bookmarks.xml\n"
"# will be generated. Another good choice would be to set it to a folder in your\n"
"# Dropbox path (or similar). This will allow automatic syncronization across\n"
"# multiple computers.\n"
"#\n"
"# sync_bookmarks_path = config_path\n"
"# bookmarks_filename = bookmarks.xml\n"
"#\n"
"# A similar syncronization naming strategy can be use with your feeds masterlist\n"
"# This allows you to sync feeds across multiple computers. Simply unset the\n"
"# sync_feeds_path variable. It will default to searching in the config_path,\n"
"# unless another path is provided. Note it doesn't ensure sycnronized feed\n" 
"# items as these may change between updates depending on each feed.\n"
"#\n"
"# sync_feeds_path = config_path\n"
"# feeds_filename = feeds.xml\n\n";


    file_put_contents( config_path.str, conf.str );
}

static void read_config()
{
    // X db_path
    // X curl_timeout_sec
    // X pager
    // X browser
    // X text_browser
    // X instapaper_username
    // X instapaper_password

    // - download_path
    // - rss_list_title_maxlen 
    // - text_field_max_len --impose max-lengths for large description & title elements. 0 is no limit;
    // - max_reports_save 
    // - enable_progress_meter 
    // - rss_show_description_len 
    // - config_strip_html_on 
    // - empty_date_set_to_current_time 
    // - update_title_len
    // X feed_timeouts_limit 
    // - disable_accelerated_menus


    basicString_t file;

    if ( 0 == file_get_contents( config_path.str, file ) ) {
        error( "config not found. This should never happen." );
    }

    basicArray_t *lines = file.explode( "\n", 1 /*rm comments*/ );

    for ( unsigned int i = 0; i < lines->count(); i++ )
    {
        //
        basicArray_t *tokens = (*lines)[i].explode();

        // join back together and then split over '='
        basicString_t *line = tokens->implode();
        delete tokens;
        tokens = line->explode( "=" );
        delete line;

        // of the type: lhs, rhs
        if ( tokens->count() == 2 )
        {
            basicString_t& lhs = (*tokens)[0];
            basicString_t& rhs = (*tokens)[1];

            if ( lhs == "db_fullpath" ) {
                db_fullpath = rhs;
            } 
            else if ( lhs == "instapaper_username" ) {
                instapaper_username = rhs;
            } 
            else if ( lhs == "instapaper_password" ) {
                instapaper_password = rhs;
            }
            else if ( lhs == "pager" ) {
                const char * exists = file_exists(rhs.str);
                if ( exists )
                    pager_path = exists;
            }
            else if ( lhs == "browser" ) {
                const char * exists = file_exists(rhs.str);
                if ( exists )
                    browser_path = exists;
            }
            else if ( lhs == "text_browser" ) {
                const char * exists = file_exists(rhs.str);
                if ( exists )
                    text_browser_path = exists;
            }
            else if ( lhs == "curl_timeout_sec" ) {
                int to_i = atoi(rhs.str);
                if ( to_i != 0 ) // atoi returns 0 when arg isnt integer
                    curl_timeout_sec = to_i;
            }
            else if ( lhs == "slideshow_speed" ) {
                int to_i = atoi(rhs.str);
                if ( to_i != 0 ) // atoi returns 0 when arg isnt integer
                    slideshow_speed = to_i;
            }
            else if ( lhs == "feed_timeouts_limit" ) {
                int to_i = atoi(rhs.str);
                if ( to_i != 0 ) // atoi returns 0 when arg isnt integer
                    feed_timeouts_limit = to_i;
            }
        }

        delete tokens;
    }
    
    delete lines;
}

static void setup_db_and_config()
{
    // detect system
    //system_name = get_sysname();
    system_name = system_id(); // misc.cpp from sys/utsname.h uname()

#if 0
    // username
    username = get_username();

    // default path to store config and database
    if ( !config_dir.str || !*config_dir.str ) 
    {
        const char * dir = 0;
        switch ( *system_name.str )
        {
        case 'D': // Darwin
            dir = "/Users";
            break;
        case 'L': // Linux
        default:
            dir = "/home";
            break;
        }
        config_dir.sprintf( "%s/%s/%s", dir, username.str, ".rss" );
    }
#endif

    username = getenv( "USER" ) ? getenv( "USER" ) : getenv( "LOGNAME" ); 

    // this should be the most portable
    if ( !config_dir.str || !*config_dir.str ) {
        config_dir.sprintf( "%s/%s", getenv( "HOME" ), ".rss" );
    }

    // if config_dir doesn't exist, create it, and write default config, set 0700
    if ( ! file_exists( config_dir.str ) ) {
        make_dir( config_dir.str, 0700 );
    }

    // set config_path if not set at commandline
    if ( 0 == config_path.length() )
        config_path.sprintf( "%s/config", config_dir.str );


    // 
    //  Config file setting
    //

    // create a default config on a first run
    if ( ! file_exists( config_path.str ) ) {
        write_default_config();
    }
    else {
        // or else read 
        read_config(); 
    }


    // db_path defaults to config_dir
    if ( db_path.length() == 0 )
        db_path = config_dir;

    // if db_fullpath_explicit is set, 
    try_setup_explicit_db();

    // hasnt been set yet, set to default
    if ( db_fullpath.length() == 0 )
        db_fullpath.sprintf( "%s/%s", db_path.str, db_name );

    // if database doesn't exist, prompt user to create new, empty one
    const char * p_expanded = file_exists( db_fullpath.str );
    if ( p_expanded ) 
    {
        // set to expanded path
        db_fullpath = p_expanded;

        // set in DBA
        DBA.setName( db_fullpath.str );
    } 
    else 
    {
        // prompt user: 
        printf( "database not found. " );
        fflush(stdout);

#if 0
        const char * ans = get_input();
        // if (! RETURN,'Y','y'), exit politely
        if ( !*ans /*return*/ || strcasecmp( ans, "Y" ) != 0 ) {
            printf( "database create aborted\n" );
            fflush(stdout);
            exit(EXIT_SUCCESS);
        }
#endif

        // set in DBA
        DBA.setName( db_fullpath.str );

        printf( "creating database: \"%s\"\n", db_fullpath.str );

        //  create db
        CreateDB();

        printf( "Database created successfully.\n" );
    }

    // look for html2text, disable and warn() if not found
    //  getenv("PATH")
    // if found, set fullpath as config_variable

    
    // get console dimensions
    struct winsize w;
    memset( &w, 0, sizeof(struct winsize) );
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    term_lines = w.ws_row ? w.ws_row : 24;
    term_cols = w.ws_col ? w.ws_col : 80;

    //
    srandom(getpid() * time(0));

    const char ** pp = 0;
    const char * f = 0;

    // pager_path search order: less, more, cat
    if ( !pager_path.length() ) {
        const char * ppath[] = { "less", "more", "cat", 0 };
        pp = ppath;
        do {
            if ( (f = search_path( *pp )) ) {
                pager_path = f;
                break;
            }
        } while ( *++pp );
    }

    // browser_path: open, xdg-open, sensible-browser, google-chrome, firefox
    if ( !browser_path.length() ) {
        const char * bpath[] = { "open", "xdg-open", "sensible-browser", "google-chrome", "firefox.bin", 0 };
        pp = bpath;
        if ( system_name.first() == 'L' )
            ++pp;
        do {
            if ( (f = search_path( *pp )) ) {
                browser_path = f;
                break;
            }
        } while ( *++pp );
    }

    // text_browser_path: lynx, links
    if ( ! text_browser_path.length() ) {
        const char * tbpath[] = { "lynx", "links", 0 };
        pp = tbpath;
        do {
            if ( (f = search_path( *pp )) ) {
                text_browser_path = f;
                break;
            }
        } while ( *++pp );
    }
}



int scrapeOpml( const XMLElement * elt, FeedBuffer_t& FB )
{
    if ( !elt )
        return 0;

    basicString_t OUTLINE( "outline" );
    basicString_t XMLURL( "xmlUrl" );
    basicString_t HTMLURL( "htmlUrl" );
    basicString_t TITLE( "title" );
    basicString_t DESCRIPTION( "description" );
    basicString_t DISABLED( "disabled" );
    basicString_t TYPE( "type" );


    for ( const XMLElement * sib = elt; sib; sib=sib->NextSiblingElement() ) 
    {
        const char * val = sib->Value();
        if ( !val )
            continue;
        if ( OUTLINE.icompare(val) && (sib->FindAttribute( "xmlUrl" ) || sib->FindAttribute( "htmlUrl" )) )
        {
            FB.startNew();
            for( const XMLAttribute *attr = sib->FirstAttribute(); attr; attr=attr->Next() ) 
            {
                val = attr->Name();
                if ( !val )
                    continue;

                if ( TITLE.icompare( val ) ) {
                    FB.setTitle( attr->Value() );
                } else if ( XMLURL.icompare( val ) ) {
                    FB.setXmlUrl( attr->Value() );
                } else if ( HTMLURL.icompare( val ) ) {
                    FB.setHtmlUrl( attr->Value() );
                } else if ( DESCRIPTION.icompare( val ) ) {
                    FB.setDescription( attr->Value() );
                } else if ( DISABLED.icompare( val ) ) {
                    FB.setDisabled( attr->Value() );
                } else if ( TYPE.icompare( val ) ) {
                    FB.setType( attr->Value() );
                }
            }
        }
        else
            scrapeOpml( sib->FirstChildElement(), FB );
    }

    return 0;
}


static size_t _storeUrl( void *stringBuffer, size_t size, size_t nmemb, void * VoidObject )
{
    if ( size > 0 && nmemb > 0 ) 
    {
        // FIXME: use C++ cast
        basicString_t * returnData = (basicString_t *) VoidObject;
        returnData->append( (const char*)stringBuffer, (unsigned) (size * nmemb) );
    }
    return nmemb;
}

int get_url_with_curl( const char * url, basicString_t& returnData, bool follow = true )
{
    CURL * curl = curl_easy_init();
    if ( !curl ) {
        warning( "failure in curl_easy_init()\n" );
        return 0;
    }

    curl_easy_setopt( curl, CURLOPT_URL, url );

    /* example.com is redirected, so we tell libcurl to follow redirection */ 
    if ( follow )
        curl_easy_setopt( curl, CURLOPT_FOLLOWLOCATION, 1L );
    else
        curl_easy_setopt( curl, CURLOPT_FOLLOWLOCATION, 0L );

    /* send all data to this function  */ 
    curl_easy_setopt( curl, CURLOPT_WRITEFUNCTION, _storeUrl );

    /* pass in the obj as void* */
    curl_easy_setopt( curl, CURLOPT_WRITEDATA, &returnData );

    /* lets see if we can get a progress meter */
    if ( enable_progress_meter )
        curl_easy_setopt( curl, CURLOPT_NOPROGRESS, 0L);
    else
        curl_easy_setopt( curl, CURLOPT_NOPROGRESS, 1L);

    /* some servers dont like an empty user-agent so we provide one */
    curl_easy_setopt( curl, CURLOPT_USERAGENT, curl_user_agent.str );

    /* */
    curl_easy_setopt( curl, CURLOPT_TIMEOUT, curl_timeout_sec );

    /* Perform the request, res will get the return code */ 
    CURLcode res = curl_easy_perform( curl );

    /* Check for errors */ 
    if ( res != CURLE_OK ) {
        warning( "curl_easy_perform() failed: %s\n", curl_easy_strerror(res) );
        curl_easy_cleanup( curl );
        return 0;
    }

    /* always cleanup */ 
    curl_easy_cleanup( curl );
    curl_global_cleanup();

    return 1;
}

const char * get_last_forwarded_url( const char * uri )
{
    static basicString_t final;

    if ( !uri || !*uri )
        return 0;

    final.erase();

    basicString_t test( uri );

    // code to get the real URL for Feedburner and Google's feedproxy
    // Pull url and return contents of <A HREF=
    if ( test.strstr( "http://feedproxy.google.com/" ) == test.str || test.strstr( "http://feeds.feedburner.com/" ) == test.str )
    {
        if ( !get_url_with_curl( uri, test, false /* no follow, snag the message instead */ ) )
            return uri;
        if ( test.length() == 0 )
            return uri;
        const char * anchor = test.strstr( "<A HREF=" );
        if ( !anchor )
            return uri;
        anchor += 9;
        const char * p = anchor;
        while ( *p && *p != '"' )
            ++p;
        final.strncpy( anchor, p - anchor );
        return final.str;
    }


    CURL * curl = curl_easy_init();
    if ( !curl ) {
        warning( "failure in curl_easy_init()\n" );
        return 0;
    }
    curl_easy_setopt( curl, CURLOPT_URL, uri );
    curl_easy_setopt( curl, CURLOPT_SSL_VERIFYPEER, false );
    curl_easy_setopt( curl, CURLOPT_URL, uri );
    curl_easy_setopt( curl, CURLOPT_HEADER, 0 );
    curl_easy_setopt( curl, CURLOPT_AUTOREFERER, 1 );
    curl_easy_setopt( curl, CURLOPT_FOLLOWLOCATION, 1 );
    curl_easy_setopt( curl, CURLOPT_MAXREDIRS, 5 );
    curl_easy_setopt( curl, CURLOPT_TIMEOUT, 30 );

    char * effective_url;
    curl_easy_getinfo( curl, CURLINFO_EFFECTIVE_URL, &effective_url );
    final = effective_url;

    curl_easy_cleanup( curl );
    curl_global_cleanup();

    return final.str;
}



// 
int have_item( Item_t& item )
{
    /*
     * item has 1-to-many feed relationship
     *
     * We check for items that that have: the same date (just the date part), AND same title
     *
     * if this item doesn't have date || title, we start checking: decription, media_url, item_url, content.  
     *  We must match against something, else the gesture would be futile. The goal is to match against 2 fields.
     *
     * if the item exists, but this particular item.feed_id is not noted in item_feeds.item_id = item_id, 
     *  an entry is added into item_feeds, return 1 (have item)
     *
     *
     * HOW TO DETERMINE WHETHER ITEM MATCHES ANOTHER ITEM
     *
     *          feed_id date    title   item_url_media_url(both together must match)
     *      S   -       M       M       M
     *
     *      N   d       x       M       M
     *      S   M       x       M       M
     *
     *      N   d       M       x       M
     *      S   M       M       x       M
     *
     *      N   d       M       M       x
     *      S   M       M       M       x
     *
     *      N   -       M       d       d
     *      N   -       d       M       d
     *      N   -       d       d       M
     *      N   -       d       d       d
     *
     * key: S=same, N=not same, -=feed_id doesnt matter, M=match, x,d=does not match
     *
     * there are 4 conditions where the item matches, and 12 where it does not, so it 
     *  follows to look only for matches, none being found we know we have a new item.
     * The 4 matching coditions are: 
     *      S   x       M       M       M
     *      S   M       x       M       M
     *      S   M       M       x       M
     *      S   M       M       M       x
     *
     * Therefor we do: 
     *  - determine what fields our item has. All items have feed_id; media_url+item_url are concatenated. 
     *  - does our item have at least 2 of the 3: (date,title,item_url+media_url)? If not, Item is unique.
     *  - If our item has 3 of 3, we do: select id, substr(sqldate,0,11) as date,title,item_url,media_url from item where date='%s',title='%s',item_url='%s',media_url='%s'.  If numRows() > 0, we have a match, else unique
     *  - else our item has 2 of 3, we must match the 2 we have & feed_Id. If those match => MATCH, else Unique
     *
     * to simplify this process, we'll do all the member determination in get_hash(), where in all the valid cases,
     *  a hash will be generated by concatenating the appropriate fields together, or 0 when when one of the valid 
     *  cases are not met.  hash=0 items are always unique.  In order for an item to possess some form of discernable
     *  identify, it must have 3 out of the 4 fields present. Otherwise an item does not possess sufficient enough
     *  information to justify an hashable identity.  The order which we look is date+title+url first, failing one
     *  of those, we do any 2 + feed_id.  So the hashes will always be uniform according to this flow-chart.
     */ 


    // safety first
    DBA.fixQuotes( item.title );
    DBA.fixQuotes( item.media_url );
    DBA.fixQuotes( item.item_url );


    basicString_t query;
    basicString_t buf;
    basicString_t url; 
    basicString_t& title = item.title;
    basicString_t date = item.sqldate.substr(0,10);


    // need to construct custom string for url, since we are matching against all, one, the other, or none
    //  depending on what the item has
    if ( item.item_url.length() && item.media_url.length() )
        url.sprintf( "and item_url = '%s' and media_url = '%s'", item.item_url.str, item.media_url.str );
    else if ( item.item_url.length() )
        url.sprintf( "and item_url = '%s'", item.item_url.str );
    else if ( item.media_url.length() )
        url.sprintf( "and media_url = '%s'", item.media_url.str );


    bool found = false;
    DBResult * res = 0;

    // the 4 matching conditions 
    if ( title.length() && date.length() && url.length() ) 
    {
        query = buf.sprintf( "select feed_id,item_id, substr(sqldate,0,11) as date from item_feeds,item where item_feeds.item_id=item.id and (date='%s' and title='%s' %s);", date.str, title.str, url.str );
        res = DBA( query.str );
        found = res != 0 && res->numRows() > 0;
    }

    if ( !found && title.length() && date.length() ) 
    {
        query = buf.sprintf( "select feed_id,item_id, substr(sqldate,0,11) as date from item_feeds,item where item_feeds.item_id=item.id and (feed_id=%d and date='%s' and title='%s');", item.feed_id, date.str, title.str );
        res = DBA( query.str );
        found = res != 0 && res->numRows() > 0;
    }

    if ( !found && title.length() && url.length() ) 
    {
        query = buf.sprintf( "select feed_id,item_id, substr(sqldate,0,11) as date from item_feeds,item where item_feeds.item_id=item.id and (feed_id=%d and title='%s' %s);", item.feed_id, title.str, url.str );
        res = DBA( query.str );
        found = res != 0 && res->numRows() > 0;
    }

    if ( !found && date.length() && url.length() ) 
    {
        query = buf.sprintf( "select feed_id,item_id, substr(sqldate,0,11) as date from item_feeds,item where item_feeds.item_id=item.id and (feed_id=%d and date='%s' %s);", item.feed_id, date.str, url.str );
        res = DBA( query.str );
        found = res != 0 && res->numRows() > 0;
    }


    if ( !found ) {
        return 0; // item definitely doesn't exist
    }

    // see if item already placed here by this feed_id
    DBRow * row;
    while ( (row = res->NextRow()) )
    {
        DBValue * v = row->FindByName( "feed_id" );
        if ( v && v->getInt() == item.feed_id )
        {
            return 1; // item already a member of this feed; we have it.
        }
    }

    // note: only gets here for the first type: title,date,url all match, but feed_id is different
    //       so we have the item already, but must add the entry in the connector table so this feed also gets it

    // item exists but is not yet member of this feed, add it
    res->resetRowCount();

    // get item_id
    DBValue * v = res->FindByNameFirstRow("item_id");
    int item_id = v ? v->getInt() : 0;

    if ( 0 == item_id ) {
        warning( "problem finding item_id. this should never happen.\n" );
        return 0;
    }

    DBA( buf.sprintf( "insert into item_feeds (item_id,feed_id) values (%d,%d);", item_id, item.feed_id ).str );

    return 1; // wasn't a member of this feed, but we connected it and say we have it
}

int insert_item( Item_t& item )
{
    // title, media_url, item_url escaped in have_item(). Don't do twice!
    DBA.fixQuotes( item.description );
    DBA.fixQuotes( item.pubDate );
    DBA.fixQuotes( item.content );
    DBA.fixQuotes( item.author );

    basicString_t query( "insert into item(" );
    basicString_t values( ") values (" );
    basicString_t buf;


    // construct query dynamically, to avoid sprintf'ing null strings, which show up as the string: "(null)"
    if ( item.title.length() ) {
        query += "title,";
        values += buf.sprintf( "'%s',", item.title.str );
    }
    if ( item.description.length() ) {
        query += "description,";
        values += buf.sprintf( "'%s',", item.description.str );
    }
    if ( item.pubDate.length() ) {
        query += "pubDate,";
        values += buf.sprintf( "'%s',", item.pubDate.str );
    }
    if ( item.sqldate.length() ) {
        query += "sqldate,";
        values += buf.sprintf( "'%s',", item.sqldate.str );
    }
    if ( item.media_url.length() ) {
        query += "media_url,";
        values += buf.sprintf( "'%s',", item.media_url.str );
    }
    if ( item.item_url.length() ) {
        query += "item_url,";
        values += buf.sprintf( "'%s',", item.item_url.str );
    }
    if ( item.content.length() ) {
        query += "content,";
        values += buf.sprintf( "'%s',", item.content.str );
    }
    if ( item.author.length() ) {
        query += "author,";
        values += buf.sprintf( "'%s',", item.author.str );
    }
    if ( item.hash.length() ) {
        query += "hash,";
        values += buf.sprintf( "'%s',", item.hash.str );
    }

    // tag is always N
    query += "tag";
    query += values += "'N');";


    DBResult * insertRes = DBA( query.str );
    if ( insertRes ) {
        int item_id = insertRes->lastInsertId();
        DBA( query.sprintf( "insert into item_feeds(item_id,feed_id) values (%d, %d);", item_id, item.feed_id ).str );
        return item_id;
    }
    
    return 0;
}


int highest_feed_id()
{
    DBResult * R = DBA( "select max(id) as max from feed;" );
    DBValue * v = R ? R->FindByNameFirstRow( "max" ) : 0;
    if ( v )
        return v->getInt();
    return 1;
}

int highest_item_id()
{
    DBResult * R = DBA( "select max(id) as max from item;" );
    DBValue * v = R ? R->FindByNameFirstRow( "max" ) : 0;
    if ( v )
        return v->getInt();
    return 1;
}

int finish_conditional_item_insert( Item_t& item, int * high_item_id, basicString_t * saved_ids )
{
    // easier to set items w/o date to current time
    if ( empty_date_set_to_current_time && item.sqldate.length() == 0 ) {
        item.sqldate = sqldate_now();
    }

    // for consistency, trim before generating hash
    item.trim();

    // gen hash before escaping quotes
    item.gen_hash();

    // add
    if ( !have_item( item ) ) 
    {
        if ( insert_item( item ) ) 
        {
            ++(*high_item_id);

            if ( saved_ids ) // keep a record
            {
                if ( saved_ids->length() )
                    saved_ids->append( "," );
                basicString_t buf;
                buf.sprintf( "%d", *high_item_id ); 
                saved_ids->append( buf );
            }

            return 1; // inserted one
        }
    }

    return 0; // had already
}


int insert_items_atom( const XMLElement * elt, int feed_id, basicString_t * saved_ids, int high_item_id )
{
    Item_t item;
    int num_inserted = 0;
    int transaction_started = 0;


    /*
        title       --> <title>
        description --> <summary>
        pubDate     --> <published> | <updated>
        media_url   -->
        item_url    --> <link type="text/html" href= | <id>
        content     --> <content>
        author      --> <author><name>
    */
    basicString_t ENTRY("entry");
    basicString_t TITLE("title");
    basicString_t SUMMARY("summary");
    basicString_t PUBLISHED("published");
    basicString_t UPDATED("updated");
    basicString_t LINK("link");
    basicString_t TEXT_HTML( "text/html" );
    basicString_t CONTENT( "content" );
    basicString_t AUTHOR( "author" );
    basicString_t NAME( "name" );
    basicString_t ID( "id" );

    // foreach item (in reverse so that newer posts are higher row id))
    for ( const XMLElement * field = elt->LastChildElement( "entry" ); field; field=field->PreviousSiblingElement() )
    {
        if ( ! ENTRY.icompare(field->Value()) )
            continue;

        // found at least one item to insert; begin transaction
        if ( !transaction_started ) {
            DBA.BeginTransaction();
            transaction_started = 1;
        }

        item.clear();
        item.feed_id = feed_id;

        // foreach child of entry element
        for ( const XMLElement * sub = field->FirstChildElement(); sub; sub = sub->NextSiblingElement() )
        {
            const char * eltName = sub->Value();
            if ( !eltName )
                continue;

            if ( TITLE.icompare(eltName) )
            {
                const XMLNode * text = sub->FirstChild();
                if ( text )
                    item.title = text->Value();
            } 
            else if ( SUMMARY.icompare(eltName) )
            {
                const XMLNode * text = sub->FirstChild();
                if ( text )
                    item.description = text->Value();
            }
            else if ( PUBLISHED.icompare(eltName) )
            {
                // higher priority than UPDATED, so will overwrite if we have it
                const XMLNode * text = sub->FirstChild();
                if ( text ) {
                    item.pubDate = text->Value();
                    item.sqldate = get_sqldate( item.pubDate );
                }
            }
            else if ( UPDATED.icompare(eltName) )
            {
                if ( ! item.pubDate.length() ) {
                    const XMLNode * text = sub->FirstChild();
                    if ( text ) {
                        item.pubDate = text->Value();
                        item.sqldate = get_sqldate( item.pubDate );
                    }
                }
            }
            else if ( LINK.icompare(eltName) )
            {
                // link has higher priority than id, so will overwrite it if found
                const XMLAttribute * attr = sub->FindAttribute( "type" );
                if ( attr && TEXT_HTML.icompare(attr->Value()) ) {
                    attr = sub->FindAttribute( "href" );
                    if ( attr )
                        item.item_url = attr->Value();
                }
            }
            else if ( ID.icompare(eltName) ) {
                if ( !item.item_url.length() ) {
                    const XMLNode * text = sub->FirstChild();
                    if ( text )
                        item.item_url = text->Value();
                }
            }
            else if ( CONTENT.icompare(eltName) )
            {
                const XMLNode * text = sub->FirstChild();
                if ( text )
                    item.content = text->Value();
            }
            else if ( AUTHOR.icompare(eltName) )
            {
                const XMLElement * elt = sub->FirstChildElement("name");
                if ( elt ) {
                    const XMLNode * text = elt->FirstChild();
                    if ( text )
                        item.author = text->Value();
                }
            }
        }

        // done scanning item elements
        if ( finish_conditional_item_insert( item, &high_item_id, saved_ids ) )
            ++num_inserted;
    }

    if ( transaction_started )
        DBA.Commit();

    return num_inserted;
}

int insert_items_rss( const XMLElement * elt, int feed_id, basicString_t * saved_ids, int high_item_id )
{
    Item_t item;
    int num_inserted = 0;
    int transaction_started = 0;

    // both rdf & rss have a channel
    const XMLElement * channel = elt->FirstChildElement( "channel" );
    if ( !channel ) {
        channel = elt->FirstChildElement( "rss:channel" );
        if ( !channel ) {
            warning ( "rss feed type not rss 2.0 or rdf\n" );
            return 0;
        }
    }

    basicString_t ITEM( "item" );
    basicString_t RSS_ITEM( "rss:item" );

    const char * item_name = "item";

    // see if RDF
    // FIXME: some known-good rss feeds are failing here
    if ( ! channel->FirstChildElement( "item" ) ) 
    {
        channel = elt; // channel set to parent 
        
        elt = channel->FirstChildElement( "item" );
        if ( !elt ) {
            elt = channel->FirstChildElement( "rss:item" );
            if ( elt ) 
                item_name = "rss:item";
        }
        if ( !elt || (!ITEM.icompare(elt->Value()) && !RSS_ITEM.icompare(elt->Value())) ) {
            warning ( "feed has no items\n" );
            return 0;
        }
    }


    basicString_t TITLE( "title" );
    basicString_t RSS_TITLE( "rss:title" );
    basicString_t DESCRIPTION( "description" );
    basicString_t ITUNES_SUMMARY( "itunes:summary" );
    basicString_t ITUNES_SUBTITLE( "itunes:subtitle" );
    basicString_t PUBDATE( "pubdate" );
    basicString_t DC_DATE( "dc:date" );
    basicString_t ENCLOSURE( "enclosure" );
    basicString_t MEDIA_CONTENT( "media:content" );
    basicString_t LINK( "link" );
    basicString_t RSS_LINK( "rss:link" );
    basicString_t GUID( "guid" );
    basicString_t ATOM_LINK( "atom:link" );
    basicString_t CONTENT_ENCODED( "content:encoded" );
    basicString_t AUTHOR( "author" );
    basicString_t DC_CREATOR( "dc:creator" );
    basicString_t ITUNES_AUTHOR( "itunes:author" );


    // foreach item (in reverse so that older posts are lower row id))
    for ( const XMLElement * field = channel->LastChildElement( item_name ); field; field=field->PreviousSiblingElement() )
    {
        if ( !ITEM.icompare( field->Value() ) && !RSS_ITEM.icompare( field->Value() ) )
            continue;

        // found at least one item to insert; begin transaction
        if ( !transaction_started ) {
            DBA.BeginTransaction();
            transaction_started = 1;
        }

        item.clear();
        item.feed_id = feed_id;

        /*
            title       --> <title>
            description --> <description> | <itunes:summary> | <itunes:subtitle>
            pubDate     --> <pubDate> | <dc:date>
            media_url   --> <enclosure url= | <media:content url=
            item_url    --> <link> | <guid> | <atom:link href=
            content     --> <content:encoded>
            author      --> <author> | <dc:creator> | <itunes:author>
        */

        // foreach child of item element
        for ( const XMLElement * sub = field->FirstChildElement(); sub; sub = sub->NextSiblingElement() )
        {
            const char * eltName = sub->Value();
            if ( !eltName )
                continue;

            if ( TITLE.icompare(eltName) || RSS_TITLE.icompare(eltName) )
            {
                const XMLNode * text = sub->FirstChild();
                if ( text )
                    item.title = text->Value();
            } 
            else if ( DESCRIPTION.icompare(eltName) ) 
            {
                // no constraint: will override other description; higher priority
                const XMLNode * text = sub->FirstChild();
                if ( text ) 
                    item.description = text->Value();
            } 
            else if ( ITUNES_SUMMARY.icompare(eltName) || ITUNES_SUBTITLE.icompare(eltName) )
            {
                if ( ! item.description.length() ) {
                    const XMLNode * text = sub->FirstChild();
                    if ( text ) 
                        item.description = text->Value();
                }
            }
            else if ( PUBDATE.icompare(eltName) )
            {
                // higher priority than DC_DATE
                const XMLNode * text = sub->FirstChild();
                if ( text ) {
                    item.pubDate = text->Value();
                    item.sqldate = get_sqldate( item.pubDate );
                }
            }
            else if ( DC_DATE.icompare(eltName) )
            {
                if ( !item.pubDate.length() ) {
                    const XMLNode * text = sub->FirstChild();
                    if ( text ) {
                        item.pubDate = text->Value();
                        item.sqldate = get_sqldate( item.pubDate );
                    }
                }
            }
            else if ( ENCLOSURE.icompare(eltName) || MEDIA_CONTENT.icompare(eltName) )
            {
                if ( !item.media_url.length() ) {
                    const XMLAttribute * attr = sub->FindAttribute( "url" );
                    if ( attr )
                        item.media_url = attr->Value();
                }
            }
            else if ( LINK.icompare(eltName) || ATOM_LINK.icompare(eltName) || GUID.icompare(eltName) || RSS_LINK.icompare(eltName) )
            {
                if ( !item.item_url.length() ) {
                    const XMLNode * text = sub->FirstChild();
                    if ( text )
                        item.item_url = text->Value();
                }
            }
            else if ( CONTENT_ENCODED.stristr(eltName) )
            {
                const XMLNode * text = sub->FirstChild();
                if ( text )
                    item.content = text->Value();
            }
            else if ( AUTHOR.icompare(eltName) || DC_CREATOR.icompare(eltName) || ITUNES_AUTHOR.icompare(eltName) )
            {
                if ( !item.author.length() ) {
                    const XMLNode * text = sub->FirstChild();
                    if ( text )
                        item.author = text->Value();
                }
            }
        }

        // done scanning item elements
        if ( finish_conditional_item_insert( item, &high_item_id, saved_ids ) )
            ++num_inserted;
    }

    if ( transaction_started )
        DBA.Commit();

    return num_inserted;
} // insert_items_rss


// returns 0 if item hits timeout limit, # of timeouts otherwise
int check_timeouts( int feed_id )
{
    basicString_t buf;
    DBResult * res = DBA( buf.sprintf( "select timeouts from feed where id = %d;", feed_id ).str );
    DBValue * v = res ? res->FindByNameFirstRow( "timeouts" ) : 0;
    int to = v ? v->getInt() : 0;

    // increment and note 
    DBA( buf.sprintf( "update feed set timeouts = %d where id = %d;", ++to, feed_id ).str );

    // reached limit
    if ( to >= feed_timeouts_limit )
        return 0; 

    return to;
}

void reset_timeouts( int feed_id )
{
    basicString_t buf;
    DBResult * res = DBA( buf.sprintf( "select id from feed where id = %d and timeouts = 0 and (errmsg is null or errmsg = '');", feed_id ).str );
    if ( res && res->numRows() == 1 )
        return;
    DBA( buf.sprintf( "update feed set timeouts = 0, errmsg = '' where id = %d;", feed_id ).str );
}

int update_timeouts_disable_if_needed( int feed_id )
{

    //
    // check timouts, print warning, or fall-through & disable feed
    //
    int to;
    if ( (to = check_timeouts( feed_id )) != 0 ) {
        warning( "Feed timed out %s time\n", to > 9 ? "nth" : ordinals[to] );
        return to;
    }

    
    // disable feed
    // set feed.type = "bad feed or unrecognized type";
    basicString_t buf;
    DBA( buf.sprintf("update feed set disabled = 1, errmsg = 'Feed hit timeout limit. Bad link or unrecognized' where id = %d;", feed_id ).str );
    
    warning( "Feed disabled after %d failed attempts.  '%s enable %d' to reset.  '%s dump -f %d' to view url contents.", feed_timeouts_limit, exename.str, feed_id, exename.str, feed_id );

    return 0;
}



// returns num new items inserted for this feed
int insert_any_new_items( const XMLDocument& document, int feed_id, int * status =0, basicString_t * saved_ids =0 )
{
    // get max items.id
    int high_item_id = highest_item_id();

    if ( status )
        *status = 1; // ok so far

    const XMLElement * elt = document.FirstChildElement( "rss" );
    if ( elt )
        return insert_items_rss( elt, feed_id, saved_ids, high_item_id );

    elt = document.FirstChildElement( "feed" );
    if ( elt )
        return insert_items_atom( elt, feed_id, saved_ids, high_item_id );

    elt = document.FirstChildElement( "rdf:RDF" );
    if ( elt )
        return insert_items_rss( elt, feed_id, saved_ids, high_item_id );


    if ( status ) 
        *status = 0; // fell through to here, signal bad feed error
    
    update_timeouts_disable_if_needed( feed_id );
    return 0; // 0 items fetched
}

int insert_feed_no_matter_what( Feed_t& feed )
{
    basicString_t query;

    // save original for printing
    basicString_t titleOrig = feed.title; 
    DBA.fixQuotes( feed.title );
    DBA.fixQuotes( feed.htmlUrl );
    DBA.fixQuotes( feed.description );

    // hack: defaulting feed type to rss if not detected elsewhere
    if ( feed.type.length() == 0 )
        feed.type = "rss";

    query.sprintf( "insert into feed(title,xmlUrl,htmlUrl,description,type,disabled) values('%s','%s','%s','%s','%s',%d);",
                    feed.title.str, feed.xmlUrl.str, feed.htmlUrl.str, feed.description.str, feed.type.str, feed.disabled );

    DBResult * insertRes = DBA( query.str );
    if ( insertRes ) {
        int id = insertRes->lastInsertId();
        printf( "added feed: [%d] \"%s\"\n", id, titleOrig.str );
        fflush(stdout);
        return id;
    } 

    return 0;
}

// returns 1 on insert, 0 if feed w/ same xmlUrl already exists
int insert_feed_if_not_exist( Feed_t& feed )
{
    basicString_t query;

    DBA.fixQuotes( feed.xmlUrl );

    // check db for matching record
    // xmlUrl is the Unique Identifier of a feed. If this changes, its a new feed!
    query.sprintf( "select * from feed where xmlUrl = '%s';", feed.xmlUrl.str );

    DBResult * res = DBA( query.str );

    // if no match, insert
    if ( !res || res->numRows() == 0 ) 
    {
        return insert_feed_no_matter_what( feed );
    }
    
    return 0;
}

inline const char * __get1stRowIfExists( const char *s, DBResult *R )
{
    DBValue * v = R->FindByNameFirstRow( s );
    if ( v ) 
        return v->getString();
    return 0;
}

const char * __getIfExists( const char * s, DBRow * R )
{
    static char buf[2] = { ' ', 0 };
    DBValue * v = R->FindByName( s );
    if ( v ) 
        return v->getString();
    return buf;
}

const char * __DontGetIfNotExist( const char * s, DBRow * R )
{
    DBValue * v = R->FindByName( s );
    if ( !v || !v->getString() )
        return 0;
    if ( strcmp( v->getString(), "(null)" ) == 0 )
        return 0;
    return v->getString();
}

Feed_t & feed_from_db( int feed_id )
{
    static Feed_t feed;
    feed.clear();
    basicString_t buf;
    DBResult *res = DBA( buf.sprintf("select * from feed where id = %d;",feed_id).str );
    if ( !res || res->numRows() < 1 )
        return feed; // id will be -1 to indicate not found
    feed.id = feed_id;
    feed.title = __get1stRowIfExists( "title", res );
    feed.description = __get1stRowIfExists( "description", res );
    feed.htmlUrl = __get1stRowIfExists( "htmlUrl", res );
    feed.xmlUrl = __get1stRowIfExists( "xmlUrl", res );
    feed.type = __get1stRowIfExists( "type", res );
    feed.priority = __get1stRowIfExists( "priority", res );
    DBValue * v = res->FindByNameFirstRow( "disabled" );
    feed.disabled = v ? v->getInt() : 0;
    v = res->FindByNameFirstRow( "timeouts" );
    feed.timeouts = v ? v->getInt() : 0;
    return feed;
}

// returns the feed w/o the id
Feed_t * feed_from_document( XMLDocument& document )
{
    static Feed_t feed;
    feed.clear();
    const XMLElement * elt = 0;

    // we need: title, link, & description, xmlUrl -from- elt Value()

    // +++ RSS +++
    XMLElement * top = document.FirstChildElement( "rss" );
    if ( top ) 
    {
        /*
        rss:
            title       --> <title>
            xmlUrl      --> <atom:link href=
            htmlUrl     --> <link>
            description --> <description> | <itunes:summary> | <itunes:subtitle>
        */
        elt = top->FirstChildElement( "channel" );
        if ( elt ) {
            const XMLElement * field = elt->FirstChildElement( "title" );
            if ( field ) {
                const XMLNode * goal = field->FirstChild();
                if ( goal )
                    feed.title = goal->Value();
            }
            field = elt->FirstChildElement( "itunes:subtitle" );
            if ( field ) {
                const XMLNode * goal = field->FirstChild();
                if ( goal )
                    feed.description = goal->Value();
            }
            field = elt->FirstChildElement( "itunes:summary" );
            if ( field ) {
                const XMLNode * goal = field->FirstChild();
                if ( goal )
                    feed.description = goal->Value();
            }
            field = elt->FirstChildElement( "description" );
            if ( field ) {
                const XMLNode * goal = field->FirstChild();
                if ( goal )
                    feed.description = goal->Value();
            }
            field = elt->FirstChildElement( "link" );
            if ( field ) {
                const XMLNode * goal = field->FirstChild();
                if ( goal )
                    feed.htmlUrl = goal->Value();
            }
            field = elt->FirstChildElement( "atom10:link" );
            if ( field ) {
                if ( feed.xmlUrl.length() == 0 ) {
                    const XMLAttribute * attr = elt->FindAttribute( "rel" );
                    if ( attr && strcmp( attr->Value(), "self" ) == 0 ) {
                        attr = elt->FindAttribute( "href" );
                        if ( attr )
                            feed.xmlUrl = attr->Value();
                    }
                }
            }

            field = elt->FirstChildElement( "type" );
            if ( field ) {
                const XMLNode * goal = field->FirstChild();
                if ( goal )
                    feed.type = goal->Value();
            }
            if ( feed.type.length() == 0 )
                feed.type = "rss";
        }

        return &feed;
    }


    // +++ ATOM +++
    top = document.FirstChildElement( "feed" );
    if ( top )
    {
        /*
        atom:
            title       --> <title>
            xmlUrl      --> <link type="application/atom+xml" href=
            htmlUrl     --> <link type="text/html href= | <link href=
            description --> <subtitle>
        */
        elt = top->FirstChildElement( "title" );
        if ( elt ) {
            const XMLNode * goal = elt->FirstChild();
            if ( goal )
                feed.title = goal->Value();
        }
        elt = top->FirstChildElement( "link" );
        if ( elt ) {
            const XMLAttribute * attr = elt->FindAttribute( "type" );
            basicString_t TEXT_HTML( "text/html" );
            if ( attr && TEXT_HTML.icompare(attr->Value()) ) {
                attr = elt->FindAttribute( "href" );
                if ( attr )
                    feed.htmlUrl = attr->Value();
            } 
            else 
            {
                const XMLAttribute * attr = elt->FindAttribute( "rel" );
                if ( attr && (strcmp( attr->Value(), "self" ) == 0 || strcmp( attr->Value(), "alternate" ) == 0) ) {
                    if ( feed.xmlUrl.length() == 0 ) {
                        attr = elt->FindAttribute( "href" );
                        if ( attr )
                            feed.xmlUrl = attr->Value();
                    }
                }
            }
        }
        elt = top->FirstChildElement( "subtitle" );
        if ( elt ) {
            const XMLNode * goal = elt->FirstChild();
            if ( goal )
                feed.description = goal->Value();
        }
        feed.type = "atom";

        return &feed;
    }


    //                  +++ RDF +++
    top = document.FirstChildElement( "rdf:RDF" );
    if ( top )
    {
        const XMLElement * field = top->FirstChildElement( "rss:channel" );
        if ( !field )
            field = top->FirstChildElement( "channel" );
        if ( field )
        {
            elt = field->FirstChildElement( "rss:title" );
            if ( !elt )
                elt = field->FirstChildElement( "title" );
            if ( elt ) {
                const XMLNode * goal = elt->FirstChild();
                if ( goal )
                    feed.title = goal->Value();
            }
            elt = field->FirstChildElement( "rss:link" );
            if ( !elt )
                elt = field->FirstChildElement( "link" );
            if ( elt ) {
                const XMLNode * goal = elt->FirstChild();
                if ( goal )
                    feed.htmlUrl = goal->Value();
            }
            elt = field->FirstChildElement( "rss:description" );
            if ( !elt )
                elt = field->FirstChildElement( "description" );
            if ( elt ) {
                const XMLNode * goal = elt->FirstChild();
                if ( goal )
                    feed.description = goal->Value();
            }
            feed.type = "RDF";
        }
    }

    return &feed;
} // feed_from_document

// gets main aspects of a feed from raw xml
Feed_t * feed_from_url_fetch( const char *xmlUrl )
{
    basicString_t fetch;

    if ( !get_url_with_curl( xmlUrl, fetch ) || fetch.length() == 0 ) {
        printf( "unable to fetch url: \"%s\"\n", xmlUrl );
        return 0;
    }

    XMLDocument document;
    document.Parse( fetch.str, fetch.length() );

    Feed_t * feed = feed_from_document( document );
    feed->xmlUrl = xmlUrl;
    return feed;
}


static void turn_off_pager()
{
    if ( 0 == pager_pid )
        return;

    kill( pager_pid, SIGKILL);

    fflush(stdout);
    fflush(stderr);
    close(1);
    close(2);

    int new_in = open( "/dev/stdin", O_WRONLY );
    int new_err = open( "/dev/stderr", O_WRONLY );

    if ( 1 != new_in ) {
        dup2( new_in, 1 );
    }
    if ( 2 != new_err ) {
        dup2( new_err, 2 );
    }
}

static void wait_for_pager(void)
{   
    fflush(stdout);
    fflush(stderr);

    /* signal EOF to pager */
    close(1);
    close(2);

    int status; 
    pid_t waiting;
    while ((waiting = waitpid(pager_pid, &status, 0)) < 0 && errno == EINTR)
        ; 
}   

static void start_pager()
{
    const char *pager, *argv0;

    if ( !config_use_pager )
        return;

    // already piping output to somewhere
    if ( !isatty(fileno(stdout)) )
        return;


    // check terminal dimensions
    // ...

    // if output lines do not exceed terminal lines, return
    // ...

    // spawn a pager & map stdout to pipe_fd[1]
    if ( pipe(pipe_fd) < 0 ) {
        error( "pipe error\n" ); 
    }

    if ( (pager_pid = fork()) < 0 ) {
        error( "fork error\n" );
    }

    // parent
    if ( pager_pid > 0 )
    {   
        close(pipe_fd[0]);

        if ( pipe_fd[1] != 1 )
        {   
            // send all writes to stdout to the pipe, to the pager process
            if ( dup2( pipe_fd[1], 1 ) != 1 ) {
                error( "dup2 error\n" ); 
            }
            if ( isatty(2) ) 
                if ( dup2( pipe_fd[1], 2 ) != 2 ) {
                    error( "dup2 error\n" ); 
                }
            close( pipe_fd[1] ); // dont need 2 handles to same stream
        }
    
        /* this makes sure the parent terminates after the pager */
        atexit(wait_for_pager);
    }

    // child
    else
    {   
        close( pipe_fd[1] );

        // cause all read() from stdin to come from pipe from parent instead
        if ( pipe_fd[0] != 0 )
        {   
            if ( dup2( pipe_fd[0], 0 ) != 0 ) {
                error( "dup2 error\n" ); 
            }
            close( pipe_fd[0] );
        }


        // setup pager
        // can be overridden by env vars: RSS_PAGER, then PAGER 
        pager = getenv( "RSS_PAGER" );
        if ( !pager ) 
            pager = getenv( "PAGER" );
        if ( !pager )
            pager = pager_path.str; // less, more, or cat

        if ( !pager ) {
            error( "No pager available. You can avoid this error with --no-pager\n" );
        }

        // tell process what to call itself
        if ( (argv0 = strrchr( pager, '/')) )
            argv0++;
        else
            argv0 = pager;


        // replaces the current process image with a new process image
        if ( execl( pager, argv0, (char*) 0 ) < 0) {
            error( "execl error\n" ); 
        }
    }
}

basicString_t& gen_rss_feed( DBResult * itemRes, const char * title =0, const char * link =0, const char * description =0, const char *generator =0 )
{
    // this is what we put it in
    static basicString_t out;
    out.erase();

    // tiny xml doc handle
    XMLDocument doc;

    /* xml version="1.0" encoding="UTF-8" */ 
    doc.InsertEndChild( doc.NewDeclaration() );

    /* rss version="2.0" */
    XMLElement * rss = doc.NewElement( "rss" );
    doc.InsertEndChild( rss );
    rss->SetAttribute( "version", "2.0" );

    /* channel */
    XMLElement * channel = doc.NewElement( "channel" );
    rss->InsertEndChild( channel );

    if ( title ) {
        XMLElement * node = doc.NewElement( "title" );
        XMLText * text = doc.NewText( title ) ;
        node->InsertEndChild( text );
        channel->InsertEndChild( node );
    }

    if ( link ) {
        XMLElement * node = doc.NewElement( "link" );
        XMLText * text = doc.NewText( link ) ;
        node->InsertEndChild( text );
        channel->InsertEndChild( node );
    }

    if ( description ) {
        XMLElement * node = doc.NewElement( "description" );
        XMLText * text = doc.NewText( description ) ;
        node->InsertEndChild( text );
        channel->InsertEndChild( node );
    }

    if ( generator ) {
        XMLElement * node = doc.NewElement( "generator" );
        XMLText * text = doc.NewText( generator ) ;
        node->InsertEndChild( text );
        channel->InsertEndChild( node );
    }

    // TODO: <lastBuildDate>Fri, 26 Apr 2013 21:33:37 -0400</lastBuildDate>
    // or
    // <dc:date>2013-04-25T07:00:00+00:00</dc:date>

    // doing it this way cuz I'm too lazy to write the tons of code needed to format the other method
    const char * dc_date = make_dcdate( sqldate_now() );
    XMLElement * node = doc.NewElement( "dc:date" );
    XMLText * text = doc.NewText( dc_date ) ;
    node->InsertEndChild( text );
    channel->InsertEndChild( node );


    // attach all the items
#define ITEM_STRING_SZ 8
    
    struct sixpack {
        basicString_t val[ITEM_STRING_SZ];
        basicString_t& operator[] ( unsigned int i ) {
            return val[i];
        }
        void clear() { 
            for ( unsigned int i = 0 ; i < ITEM_STRING_SZ; i++ ) { val[i].erase(); }
        }
    } six;

    const char * attr[] = { "title", "description", "pubDate", "guid", 
                        "link", "content:encoded", "dc:creator", "dc:date" };

    DBRow * row;
    while ( (row = itemRes->NextRow()) )
    {
        six.clear();
        six[0] = __DontGetIfNotExist( "title", row );
        six[1] = __DontGetIfNotExist( "description", row );
        six[2] = __DontGetIfNotExist( "pubDate", row );
        six[3] = __DontGetIfNotExist( "media_url", row );
        six[4] = __DontGetIfNotExist( "item_url", row );
        six[5] = __DontGetIfNotExist( "content", row );
        six[6] = __DontGetIfNotExist( "author", row );
        six[7] = __DontGetIfNotExist( "sqldate", row );
    
        // item
        XMLElement * item = doc.NewElement( "item" );
        channel->InsertEndChild( item );

        for ( int i = 0 ; i < ITEM_STRING_SZ ; i++ ) 
        {
            if ( six[i].length() ) 
            {
                // only get dc:date if we dont have pubDate
                if ( 7 == i ) {
                    if ( six[2].length() )
                        continue;
                    six[i] = make_dcdate( six[i].str );
                }

                XMLElement * node = doc.NewElement( attr[i] );
                XMLText * text = doc.NewText( six[i].str ) ;
                node->InsertEndChild( text );

                if ( 5 == i ) {
                    text->SetCData(true); // content:encoded is always <![CDATA[
                }

                // attach element to item node
                item->InsertEndChild( node );
            }
        }
    }
#undef ITEM_STRING_SZ

    // get string from tinyxml
    XMLPrinter printer;
    doc.Print( &printer );
    out = printer.CStr(); // const char* to the XML

    return out;
}

int rss_deleteBookmark( int saved_id )
{
    if ( 0 == saved_id )
        return 0;

    basicString_t buf;
    DBResult * res = DBA( buf.sprintf( "delete from saved_links where id = %d;", saved_id ).str );
    return res->rowsUpdated();
}

int rss_deleteItem( int item_id )
{
    if ( 0 == item_id )
        return 0;

  return 0; // not impl yet

/*
    basicString_t buf;
    // removes: content, description, author, hash, tag, pubDate
    //  and sets: deleted = 1
    buf.sprintf( "update item set content = '', description = '', author = '', hash = '', tag = '', pubDate = '', deleted = 1 where id = %d;", item_id );
    DBA( buf.str );
    
    return 1;
*/
}

//
// bookmarks stuff
//

void bookmark_rss_string_from_db( basicString_t **rss_pp )
{
    DBResult * res = DBA( "select distinct feed.title as ftitle, item_feeds.feed_id, item.* from feed,item_feeds,item,saved_links where item_feeds.item_id = item.id and item_feeds.feed_id = feed.id and saved_links.item_id = item.id  order by saved_links.timestamp desc;" );

    basicString_t title;
    title.sprintf( "RSS Power Tool Bookmarks for %s", username.str );

    basicString_t& string = gen_rss_feed( res, title.str, 0, 0, RSS_GENERATOR );
    *rss_pp = &string;
}

XMLDocument * bookmark_xml_from_db( void )
{
    basicString_t * string;
    bookmark_rss_string_from_db( &string );
    XMLDocument * document = new XMLDocument;
    document->Parse( string->str, string->length() );
    return document;
}

int bookmark_xml_to_db( const XMLDocument& document )
{
    const XMLElement * top = document.FirstChildElement( "rss" );
    if ( !top )
        return 0;
    const XMLElement * channel = top->FirstChildElement( "channel" );
    if ( !channel )
        return 0;
    const XMLElement * item = channel->FirstChildElement( "item" );
    if ( !item )
        return 0;

    // found item, figure it's safe to delete.
    // nuke table. assumes caller knows what they're doing
    DBA( "delete from saved_links;" );

    basicString_t ITEM( "item" );
    bool transaction_started = false;
    basicString_t buf;
    basicString_t query;
    basicString_t timestamp_base;
    timestamp_base.strncpy( sqldate_now(), 10 );
    basicString_t timestamp;
    int seconds = -1;
    int minutes = 0;
    int hours = 0; // note will fail after 86400 bookmarks

    basicString_t title;
    basicString_t pubDate;
    basicString_t dc_date;
    basicString_t media_url;
    basicString_t item_url;

    //int feed_id, item_id;

    for ( const XMLElement * field = channel->LastChildElement( "item" ); field; field=field->PreviousSiblingElement() )
    {
        if ( !ITEM.icompare( field->Value() ) )
            continue;

        // found at least one item to insert; begin transaction
        if ( !transaction_started ) {
            DBA.BeginTransaction();
            transaction_started = true;
        }

        query.erase();
        pubDate.erase();
        dc_date.erase();
        title.erase();
        media_url.erase();
        item_url.erase();

        // timestamp -- staggered by 1 second to provide correct sorting
        if ( ++seconds >= 60 ) {
            seconds = 0;
            if ( ++minutes >= 60 ) {
                minutes = 0;
                if ( ++hours >= 24 ) // will wrap around at 86400 bookmarks!
                    hours = 0;
            }
        }
        timestamp.sprintf( "%s %02d:%02d:%02d", timestamp_base.str, hours, minutes, seconds );

        // in rss feed: 
        //  "title", "description", "pubDate", "guid", 
        //  "link", "content:encoded", "dc:creator", "dc:date"
        const XMLElement * sub = field->FirstChildElement( "pubDate" );
        if ( sub )
        {
            const XMLNode * text = sub->FirstChild();
            if ( text ) 
                pubDate = text->Value();
        }

        if ( !pubDate.length() )
        {
            sub = field->FirstChildElement( "dc:date" );
            const XMLNode * text = sub->FirstChild();
            if ( !text ) 
                continue;
            dc_date = unmake_dcdate( text->Value() );
        }

        if ( !pubDate.length() || !dc_date.length() )
            continue;

        // title 
        sub = field->FirstChildElement( "title" );
        if ( !sub )
            continue;
        const XMLNode * text = sub->FirstChild();
        if ( !text ) 
            continue;
        title = text->Value();
            
        // have to query to get the ids. might not have them
        query.sprintf( "select feed_id,item_id from item_feeds,item where item_feeds.item_id = item.id and item.title = '%s'", title.str );
        if ( pubDate.length() )
            query += buf.sprintf( " and item.pubDate = '%s';", pubDate.str );
        else
            query += buf.sprintf( " and item.sqldate = '%s';", dc_date.str );

        DBResult * res = DBA( query.str );
        if ( !res )
            continue; // FIXME: we should save the links anyway if we have em

        //fields we need to set:
        //- timestamp DATETIME
        //- title TEXT
        // media_url TEXT
        // item_url TEXT
        // feed_id INTENGER
        // item_id INTENGER

        DBA( query.str );
    }

    if ( transaction_started )
        DBA.Commit();

    return 1;
}

XMLDocument * bookmark_xml_from_string( const basicString_t& buf )
{
    return 0;
}

void write_bookmarks_file()
{
}

XMLDocument * read_bookmarks_file()
{
    return 0;
}

void sync_bookmarks()
{
/*
    path = file_exists()
    if ( !path )
        db_xml = bookmark_xml_from_db();
        if ( db_xml )
            write db_xml.CStr();
        return
    file_string = file_get_contents(path)

    disk_xml = bookmark_xml_from_string(file_string);
    db_xml = bookmark_xml_from_db();
    if ( !db_xml )
        bookmark_xml_to_db( disk_xml );
        return;

    if ( db newer than disk )
        write db_xml.CStr();
    else
        bookmark_xml_to_db( disk_xml );

- must re-write bookmarks.xml every time bookmark added or deleted
*/
}

/////////////////////////////////////////////////////////////////////////////
//////////////           ^ utility methods ^                  ///////////////
////////////////////////////////CENTER///////////////////////////////////////
//////////////           v user facing functions v            ///////////////
/////////////////////////////////////////////////////////////////////////////

int rss_view_usage( const char * m =0 )
{
    if ( m )
        printf( "%s", m );
    printf( "usage: %s view <id>\n    view a feed's attributes\n", exename.str );
    return 0;
} 

int rss_view()
{
    if ( check_cmdline("-h") || check_cmdline("--help") )
        return rss_view_usage();

    if ( cmd_args.count() != 1 ) 
        return rss_view_usage( "what feed id do you wish to view?\n" );

    int feed_id = atoi( cmd_args[0]->str );
    if ( 0 == feed_id )
        return rss_view_usage( "bad feed id. Not a number.\n" );


    Feed_t& F = feed_from_db( feed_id );
    if ( -1 == F.id )
        return rss_view_usage( "Feed not found.\n" );

    // start output item
    draw_dashed_line();
    printf( "%-14s%d\n%-14s%s\n%-14s%s\n%-14s%s\n%-14s%s\n%-14s%s\n%-14s%d\n%-14s%d\n%-14s%s\n", "Feed id:", F.id, "Title:", F.title.str, "Description:", F.description.str, "xmlUrl:", F.xmlUrl.str, "htmlUrl:", F.htmlUrl.str, "type:",F.type.str, "disabled:",F.disabled, "timeouts:", F.timeouts, "priority:", F.priority.str ); 

    basicString_t buf;
    DBResult * res = DBA( buf.sprintf( "select count(item.id) as count from item,item_feeds where item.id=item_feeds.item_id and item_feeds.feed_id = %d;",feed_id ).str );
    DBValue * v = res ? res->FindByNameFirstRow( "count" ) : 0;
    int num = v ? v->getInt() : -1;

    printf( "%-14s%d\n", "num items:", num );

    // FIXME: date of newest item
    // FIXME: date of oldest item

    // end output item
    draw_dashed_line();

    return 0;
} // rss_view



void rss_add_usage( const char * msg =0 ) {
    if ( msg )
        printf( "%s\n", msg );
    
    printf( "usage: %s [-f feed_id][-n] <file|url> \n\n", exename.str );
    printf( "   no args       add url, creating feed if not exists and pull items from it\n" );
    printf( "   -n            add new feed from file\n" );
    printf( "   -f feed_id    add items to existing feed from file\n" );
}

void rss_add()
{
    if ( cmd_args.count() == 0 || check_cmdline("-h") || check_cmdline("--help") ) {
        return rss_add_usage();
    }

/* 3 cases:
- add url, pull items
- add new feed, will prompt if feed already exists w/ same xmlUrl
- add items from file to existing feed
    doesnt care about urls, items go to whatever feed_id specified 
*/
    basicString_t fetch;
    XMLDocument document;
    Feed_t * feed = 0;
    int feed_id = 0;
    bool insert_new = false;

    // url only
    if ( cmd_args.count() == 1 )        
    {
        if ( file_exists( cmd_args[0]->str ) )
            return rss_add_usage( fetch.sprintf( "looks like argument is file. In order to load %s needs to know if you would like it merged to an existing feed, or a new one created. Use --help to see options", exename.str ).str );

        if ( !get_url_with_curl( cmd_args[0]->str, fetch ) || fetch.length() == 0 ) {
            return rss_add_usage( "unable to fetch url.");
        }

        // generate XML document to get items
        document.Parse( fetch.str, fetch.length() );
        feed = feed_from_document( document );
        // overwrite xmlUrl, since we supplied it
        feed->xmlUrl = cmd_args[0]->str;
    }

    // new from file
    else if ( cmd_args.count() == 2 ) 
    {
        const char * path = file_exists( cmd_args[1]->str );
        if ( !path || *cmd_args[0] != "-n" ) {
            return rss_add_usage( "argument not a file." );
        }

        // generate XML document to get items, from path
        document.LoadFile( path );
        feed = feed_from_document( document );
        insert_new = true;
    }

    // file to existing feed_id
    else if ( cmd_args.count() == 3 ) 
    {
        const char * path = file_exists( cmd_args[2]->str );
        feed_id = atoi( cmd_args[1]->str );
        if ( !path || *cmd_args[0] != "-f" || 0 == feed_id ) {
            return rss_add_usage( "argument not a file." );
        }
        document.LoadFile( path );
        feed = feed_from_document( document );
    }
    else {
        return rss_add_usage();
    }


    // save original title before escaping quotes
    basicString_t unescaped_title = feed->title;

    // add to feeds
    if ( !feed_id && !insert_feed_if_not_exist( *feed ) ) {
        // feed already exists
        if ( insert_new ) {
            insert_feed_no_matter_what( *feed );
        }
    }

    // need it
    if ( 0 == feed_id ) {
        // get feed_id 
        basicString_t _url = feed->xmlUrl;
        DBA.fixQuotes( _url );
        DBResult * res = DBA( fetch.sprintf( "select id from feed where xmlUrl = '%s' order by id desc limit 1;", _url.str ).str );
        if ( !res )
            error( "unexpected error." );
        DBValue * val = res->FindByNameFirstRow( "id" );
        feed_id = val ? val->getInt() : 0;
    }


    // takes XMLDocument and inserts items
    int total_inserted = insert_any_new_items( document, feed_id );

    // report how many items 
    printf( "%d items pulled for %s\n", total_inserted, unescaped_title.str );


    // set last_updated correctly, from items
    DBResult * result = DBA( fetch.sprintf( "select sqldate from item,item_feeds where item.id=item_feeds.item_id and item_feeds.feed_id = %d order by item.sqldate desc limit 1;", feed_id ).str );
    if ( result ) {
        DBValue * val = result->FindByNameFirstRow( "sqldate" );
        if ( val ) {
            DBA( fetch.sprintf( "update feed set last_updated = '%s' where id = %d;", val->getString(), feed_id ).str );
        }
    }
} // rss_add


/**********************
 * rss dump
 */
static void rss_dump_usage( const char * msg =0 ) {
    turn_off_pager();
    if ( msg ) {
        printf( "%s", msg );
    }
    printf( "usage: %s dump [[-f|-l N] <feed_id>] [-b]\n\n", exename.str );
    printf( "    feed_id    dump internal storage for that feed\n" );
    printf( "    -l N       limit internal dump to N items\n" );
    printf( "    -f         dump the feed after retrieving it. Has similar effect as: curl http://feed.address.xml\n" );
    printf( "    -b         dump bookmarks as rss feed\n" );
}

void rss_dump()
{
    basicString_t *match;
    bool do_fetch = false;
    int limit = 0;

    if ( check_cmdline( "-h" ) || check_cmdline( "--help" ) )
        return rss_dump_usage();


    // dump internal of feed, or bookmarks
    if ( cmd_args.count() == 1 )
    {
        if ( *cmd_args[0] == "-b" ) {
            basicString_t * bs;
            bookmark_rss_string_from_db( &bs );
            fwrite( bs->str, 1, bs->length(), stdout );
            return;
        }
        match = cmd_args[0];
    }

    // dump fetch
    else if ( cmd_args.count() == 2 )
    {
        if ( *cmd_args[0] != "-f" )
            return rss_dump_usage();
        match = cmd_args[1];
        do_fetch = true;
    }

    // limit dump internal
    else if ( cmd_args.count() == 3 )
    {
        limit = atoi( cmd_args[1]->str );
        if ( *cmd_args[0] != "-l" || !limit )
            return rss_dump_usage();
        match = cmd_args[2];
    }

    // has to fit one of those
    else
    {
        return rss_dump_usage();
    }


    basicString_t buf;
    int prospective_id = atoi( match->str );

    if ( 0 == prospective_id ) {
        DBResult * F = DBA( buf.sprintf( "select id from feed where title like '%%%s%%' order by last_updated desc limit 1;", match->str ).str );
        if ( F && F->numRows() > 0 )
            prospective_id = F->FindByNameFirstRow("id")->getInt();
    }

    if ( 0 == prospective_id ) {
        return rss_dump_usage( "match not found\n" );
    }

    //
    Feed_t& feed = feed_from_db( prospective_id );
    if ( feed.id == -1 )
        return rss_dump_usage( "match not found\n" );

    if ( do_fetch ) {
        buf.erase();
        if ( !get_url_with_curl( feed.xmlUrl.str, buf ) || buf.length() == 0 ) {
            warning( "connection error. couldn't fetch rss feed\n" );
            return;
        }

        // run it through parser to cleanly indent
        XMLDocument document;
        document.Parse( buf.str, buf.length() );
        document.Print();
        return;
    }

    // got to here, means create rss document from internal storage
    // 
    buf.sprintf( "select item.* from item,item_feeds where item.id = item_feeds.item_id and item_feeds.feed_id = %d order by sqldate desc", feed.id );
    if ( limit != 0 ) {
        buf += " limit ";
        buf += limit;
    }
    buf += ";";
        
    DBResult * itemRes = DBA( buf.str );


    basicString_t& feedBuf = gen_rss_feed( itemRes, feed.title.str, feed.htmlUrl.str, feed.description.str, RSS_GENERATOR );

    fwrite( feedBuf.str, 1, feedBuf.length(), stdout );

} // rss_dump

const char * last_report_ids()
{
    DBResult * res = DBA( "select item_ids from reports order by id desc limit 1;" );
    if ( !res )
        return 0;
    DBValue * v = res->FindByNameFirstRow( "item_ids" );
    return v ? v->getString() : 0;
}

void print_feed_items( DBResult * res, bool newest_first =true, bool display_body =true )
{
    if ( !res )
        return ;

    // 
    basicString_t stripped;
    HtmlTagStripper detagger;

    //
    // PRINT FEED ITEM
    //
    unsigned int row_num = 1;
    DBRow * row; 
    while ( (row = res->NextRow()) )
    {
        //TAG (N,D,S,X,V), TITLE, trunc(DESCRIPTION,x), DATE, MEDIA
        basicString_t tag = __getIfExists( "tag", row );
        basicString_t title = __getIfExists( "title", row );
        basicString_t desc = __getIfExists( "description", row );
        //desc.strncpy( __getIfExists("description",row), rss_show_description_len );
        ///basicString_t date = __getIfExists( "sqldate", row );
        basicString_t date;
        date.strncpy( __getIfExists( "sqldate", row ), 16 );
        basicString_t media_url = __getIfExists( "media_url", row );
        basicString_t item_url = __getIfExists( "item_url", row );

        unsigned int item_id = newest_first ? res->numRows() - row_num + 1 : row_num;

        basicString_t ftitle;
        ftitle.strncpy( __getIfExists( "ftitle", row ), rss_show_ftitle_len );

        basicString_t feed_id = __getIfExists( "feed_id", row );
        basicString_t content = __getIfExists( "content", row );
        basicString_t author = __getIfExists( "author", row );


        printf( "[%s] %s %-2u %1s  %s  %s", feed_id.str, ftitle.str, item_id, tag.str, date.str, title.str );
        if ( author.length() )
            printf( " - %s\n", author.str );
        else
            printf( "\n" );

        // media_url
        if ( media_url.length() )
            printf ("m %s\n", media_url.str );
        // item_url
        if ( item_url.length() )
            printf ("h %s\n", item_url.str );

        if ( display_body ) 
        {
            // description
            if ( desc.str && desc != "(null)" ) {
                if ( config_strip_html_on ) {
                    detagger.strip( desc, stripped );
                    printf( "\n%s\n", stripped.str );
                } else
                    printf( "\n%s\n", desc.str );
            }

            // content:encoded
            if ( content.str && content != "(null)" ) {
                if ( config_strip_html_on ) {
                    detagger.strip( content, stripped );
                    printf( "\n%s\n", stripped.str );
                } else
                    printf( "\n%s\n", content.str );
            }
        }
        
        // demark each item
        draw_dashed_line();
            
        fflush( stdout );
        ++row_num;
    }
}

static void rss_show_usage( const char *msg =0 ) {
    turn_off_pager();
    if ( msg )
        printf( "%s", msg );
    printf( "usage: %s show [-n|-a] [-r][-s] [-l num] [-x range] [-m <feed>] [id[id2][id3][..]]\n\n", exename.str );
    printf( "    -n      show feeds from last update\n" );
    printf( "    -r      reverse sort order\n" );
    printf( "    -l N    limit items returned to N newest\n" );
    //printf( "    -l N    limit items per feed to N newest\n" );
    printf( "    -m arg  look for a match in title and return items of any feed that matches\n" );
    printf( "    -v N    show feed info for a feed id N\n" );
    printf( "    -a      show all feeds\n" );
    printf( "    -x      exclude feeds by supplying range, eg: 11-14,16,44-65. Must be no whitespace or quoted argument.\n" );
    printf( "            Feed id's can be given in ranges of the type 10,14-16,20-22. This would\n             show items from feeds 10,14,15,16,20,21,22\n" );
    printf( "    -s      show only headings, turn off contents display\n" );
}

#define CODE_SHOW_NEW       BIT(0)
#define CODE_SHOW_ALL       BIT(1)
#define CODE_SHOW_REVERSE   BIT(2)
#define CODE_SHOW_LIMIT     BIT(3)
#define CODE_SHOW_MATCH     BIT(4)
#define CODE_SHOW_VERBOSE   BIT(5)
#define CODE_SHOW_EXCLUDE   BIT(6)
#define CODE_SHOW_NO_BODY   BIT(7)

void rss_show()
{
    int qcode = 0;
    int limit = 0;
    basicString_t match_string;
    basicString_t sql_where;
    basicString_t match_ids;
    basicString_t exclude;
    basicString_t query;
    basicString_t buf;
    basicString_t verbose;
    int verbose_id = 0;

    if ( check_cmdline( "-h" ) || check_cmdline( "--help" ) || !cmd_args.count() )
        return rss_show_usage();

    for ( unsigned int i = 0 ; i < cmd_args.count() ; i++ )
    {
        // is switch/option
        if ( cmd_args[i]->str && cmd_args[i]->str[0] == '-' )
        {
            for ( unsigned int j = 1; j < cmd_args[i]->length(); j++ ) 
            {
                switch ( (*cmd_args[i])[j] ) 
                {
                case 'n':   // show items from the last update only
                    qcode |= CODE_SHOW_NEW;
                    qcode &= ~CODE_SHOW_ALL;
                    break;
                case 'a':   // show everything, all items
                    qcode |= CODE_SHOW_ALL;
                    qcode &= ~CODE_SHOW_NEW;
                    break;
                case 'r':   // reverse sort order of whatever
                    qcode |= CODE_SHOW_REVERSE;
                    break;
                case 's':   // reverse sort order of whatever
                    qcode |= CODE_SHOW_NO_BODY;
                    break;
                case 'l':   // limit items per feed 
                    qcode |= CODE_SHOW_LIMIT;
                    if ( i + 1 >= cmd_args.count() )
                        return rss_show_usage( "error: need argument\n" );
                    limit = atoi( cmd_args[1+i]->str );
                    if ( 0 == limit )
                        return rss_show_usage( "error: limit is numeric\n" );
                    *cmd_args[1+i] = "-"; // unset next-arg so it cant be be used for anything else
                    break;
                case 'm':   // match feed title by string
                    if ( i + 1 >= cmd_args.count() )
                        return rss_show_usage( "error: need argument\n" );
                    match_string = cmd_args[1+i]->str;
                    *cmd_args[1+i] = "-";
                    break;
                case 'v':
                    qcode |= CODE_SHOW_VERBOSE;
                    if ( i + 1 >= cmd_args.count() )
                        return rss_show_usage( "error: need argument\n" );
                    verbose = cmd_args[1+i]->str;
                    *cmd_args[1+i] = "-";
                    break;
                case 'x':
                    qcode |= CODE_SHOW_EXCLUDE;
                    if ( i + 1 >= cmd_args.count() )
                        return rss_show_usage( "error: need argument\n" );
                    exclude = cmd_args[1+i]->str;
                    *cmd_args[1+i] = "-";
                    break;
                }
            }
        }

        // anything that is not a known switch is perceived as a range
        else
        {
            match_ids.append( cmd_args[i]->str );
        }
    }


    if ( (qcode&CODE_SHOW_VERBOSE)==CODE_SHOW_VERBOSE)
    {
        // is it a number?
        verbose_id = atoi( verbose.str );

        // if not number, try keyword taking first match
        if ( 0 == verbose_id ) 
        {
            DBResult * res = DBA( buf.sprintf( "select * from feed where title like '%%%s%%' order by last_updated desc limit 1;", verbose.str ).str );
            if ( !res ) {
                return rss_show_usage( buf.sprintf( "can't find match for %s\n", verbose.str ).str );
            }

            DBValue * v = res->FindByNameFirstRow("id");
            if ( v ) {
                verbose_id = v->getInt();
            }
        }

        //
        // print out feed header info 
        //
        if ( verbose_id ) {

            draw_dashed_line();

            Feed_t& F = feed_from_db( verbose_id );
            printf( "%-14s%d\n%-14s%s\n%-14s%s\n%-14s%s\n%-14s%s\n%-14s%d\n", "Feed id:", verbose_id, "Title:", F.title.str, "Description:", F.description.str, "xmlUrl:", F.xmlUrl.str, "htmlUrl:", F.htmlUrl.str, "disabled:",F.disabled ); 

            draw_dashed_line();

            return;
        } 
        else 
        {
            return rss_show_usage( buf.sprintf( "no match for \"%s\"\n", verbose.str ).str );
        }
    } // end -v verbose


    // match string gets precedence over NEW, ALL, or match_ids
    if ( match_string.length() ) 
    {
        DBResult * F = DBA( buf.sprintf( "select id from feed where title like '%%%s%%' order by last_updated desc;", match_string.str ).str );
        if ( F && F->numRows() > 0 )
        {
            buf = "(";
            DBRow * row;
            while ( (row = F->NextRow()) )
            {
                DBValue * v = row->FindByName("id");
                if ( v ) {
                    int d = v->getInt();
                    buf.append( query.sprintf( "feed.id=%d or ", d ) );
                }
            }

            // re-write match_string as sql where statement
            query.strncpy( buf.str, buf.length() - 4 /* cut off trailing or */ );
            sql_where.sprintf( "%s)", query.str );
        }
    } // end -m match


    // -n new
    if ( (qcode&CODE_SHOW_NEW)==CODE_SHOW_NEW )
    {
        const char *report_ids = last_report_ids();
        if ( report_ids ) {
            if ( sql_where.length() )
                sql_where.append( " and " );

            sql_where += report_ids;
        }
        else {
            turn_off_pager();
            fprintf( stdout, "no new items to show\n" ); // shouldn't happen unless last update had no new items in it
            fflush(stdout);
            return;
        }
    }

    // look for match_ids, if found, turn into sql_where
    // match ids can be in comma-separated, or hyphenated ranges, ie "10,12,23-26,44" 
    // can use these in conjunction with new
    if ( match_ids.length() > 0 )
    {
        basicString_t &range = translate_unknown_args( match_ids.str, "feed_id" );

        if ( range.length() ) {
            if ( sql_where.length() )
                sql_where.append( " and " );
            sql_where.append( range );
        }
    }

/*
    // -a all
    else if ( (qcode&CODE_SHOW_ALL)==CODE_SHOW_ALL )
    {
        sql_where = "";
    }
*/

    // -x exclude  (exclude some from another result set, eg -n or -a
    if ( (qcode&CODE_SHOW_EXCLUDE)==CODE_SHOW_EXCLUDE )
    {
        buffer_t<unsigned int> ibuf;
        translate_str_range( exclude.str, ibuf );
    
        if ( ibuf.length() ) 
        {
            if ( sql_where.length() )
                sql_where.append( " and (" );
            else
                sql_where = "(";

            for ( unsigned int i = 0; i < ibuf.length(); i++ ) 
                sql_where.append( buf.sprintf( "feed.id!=%u and ", ibuf[i] ).str );
            
            buf.strncpy( sql_where.str, sql_where.length() - 4 );
    
            sql_where = buf += ")";
        }
    }


    // 
    // construct query string
    // 

    // 
    query = "select feed.title as ftitle, item_feeds.feed_id, item.* from feed,item,item_feeds where item_feeds.feed_id=feed.id and item_feeds.item_id=item.id";

    // constraints
    if ( sql_where.length() )
    {
        query.append( buf.sprintf( " and (%s)", sql_where.str ) );
    }

    bool newest_first = true;

    // items from last update also sort by priority
    if ( (qcode&CODE_SHOW_NEW)==CODE_SHOW_NEW )
        query.append( " order by priority desc," );
    else
        query.append( " order by " );

    // reverse
    if ( (qcode&CODE_SHOW_REVERSE)==CODE_SHOW_REVERSE ) 
    {
        query.append( "item.sqldate asc" );
        newest_first = false;
    }
    else
    {
        query.append( "item.sqldate desc" );
    }

    // limit
    if ( (qcode&CODE_SHOW_LIMIT)==CODE_SHOW_LIMIT ) 
        query.append( buf.sprintf( " limit %d;", limit ).str );
    else
        query.append( ";" );


    //    
    // actually do query
    //    
    DBResult * res = DBA( query.str );

    if ( !res || res->numRows() == 0 ) {
        printf( "No items returned.\n" );
        return;
    }

    //
    // output results to the screen
    //
    print_feed_items( res, newest_first, (qcode&CODE_SHOW_NO_BODY)!=CODE_SHOW_NO_BODY );

} // rss_show


void rss_list_usage()
{
    turn_off_pager();
    printf( "usage: %s list [-a|-u|-d|-r|-z] [match string]\n\n"    \
"    -a      - sort alphabetically \n"                             \
"    -u      - order by date of last update \n"                       \
"    -d      - order by date of last downloaded\n"                        \
"    -r      - reverse sort order\n"                                \
"    -z      - show only feeds that have zero posts in them\n"            \
"    <match> - Anything other than switches is considered a match argument.\n" \
"              Can match feeds by number (10), by range (10-20), by number\n" \
"              set combined with ranges (1,2,4-8,12) or by string (ie, blog)\n"\
"              Everything after the match string is ignored.\n"       \
, exename.str );
}

#define CODE_SORT_BY_UPDATED        BIT(0)
#define CODE_SORT_BY_DOWNLOADED     BIT(1)
#define CODE_REVERSE                BIT(2)
#define CODE_SORT_ALPHABETICALLY    BIT(3)
#define CODE_ZERO                   BIT(4)

// - order by last_updated, last_download desc/asc
// - match stringfrag
void rss_list()
{
    int qcode = 0;
    basicString_t buf;
    basicString_t match;
    basicString_t query( "select * from feed" ); 

    if ( cmd_args.count() > 0 ) 
    {
        for ( unsigned int i = 0; i < cmd_args.count(); i++ ) 
        {
            if ( (*cmd_args[i])[0] == '-' ) 
            {
                for ( unsigned int j = 1; j < cmd_args[i]->length(); j++ ) 
                {
                    switch ( (*cmd_args[i])[j] ) {
                    case 'a':
                        qcode |= CODE_SORT_ALPHABETICALLY;
                        qcode &= ~CODE_SORT_BY_DOWNLOADED;
                        qcode &= ~CODE_SORT_BY_UPDATED;
                        break;
                    case 'u':
                        qcode |= CODE_SORT_BY_UPDATED;
                        qcode &= ~CODE_SORT_BY_DOWNLOADED;
                        qcode &= ~CODE_SORT_ALPHABETICALLY;
                        break;
                    case 'd':
                        qcode |= CODE_SORT_BY_DOWNLOADED;
                        qcode &= ~CODE_SORT_BY_UPDATED;
                        qcode &= ~CODE_SORT_ALPHABETICALLY;
                        break;
                    case 'r':
                        qcode |= CODE_REVERSE;
                        break;
                    case 'z':
                        qcode |= CODE_ZERO;
                        break;
                    default:
                        rss_list_usage();
                        exit( EXIT_FAILURE );
                    }
                }
            }
            else {
                match.set( *cmd_args[i] );
                break;
            }
        }
    }

    if ( match.length() > 0 ) 
    {
        buf.sprintf( " where %s", translate_unknown_args( match.str ).str );
        query.append( buf );
    }

    if ( (qcode & CODE_SORT_BY_UPDATED)==CODE_SORT_BY_UPDATED ) {
        query.append( " order by feed.last_updated" );
    } else if ( (qcode & CODE_SORT_BY_DOWNLOADED)==CODE_SORT_BY_DOWNLOADED ) {
        query.append( " order by feed.last_downloaded" );
    } else if ( (qcode & CODE_SORT_ALPHABETICALLY)==CODE_SORT_ALPHABETICALLY ) {
        query.append( " order by feed.title" );
    } else {
        query.append( " order by feed.id" );
    }

    if ( (qcode & CODE_REVERSE) == CODE_REVERSE ) {
        query.append( " desc;" );
    } else {
        query.append( " asc;" );
    }

    // DO QUERY
    DBResult * res = DBA( query.str );
    if ( !res ) 
        error( "badly formed query: \"%s\"\n", query.str );

    if ( res->numRows() == 0 ) {
        res = DBA("select * from feed;");
        //turn_off_pager(); -- cant get to work properly, just yet
        if ( res->numRows() == 0 )
            printf( "No feeds stored. Try 'rss import' or 'rss add' to add some.\n" );
        else
            printf( "matching feeds not found\n" );
        return;
    }

    // 
    if ( res->numRows() <= (unsigned) term_lines )
        turn_off_pager();


    // MAKE DYNAMIC PRINTF FORMATS
    char id_fmt[15];
    unsigned int degree = ((unsigned int) log10( highest_feed_id() )) + 1;
    sprintf( id_fmt, "%%-%ud", degree+2 );

    char titlefmt[15];
    sprintf( titlefmt, "%%-%d.%ds", rss_list_title_maxlen+2, rss_list_title_maxlen );


    // fuck
    for ( unsigned int j = 0; j < res->numRows(); j++ )
    {
        DBRow& row = (*res)[j];

        DBValue * v = row.FindByName( "id" );
        int id = v->getInt();

        DBResult * cRes = DBA( buf.sprintf("select count(item.id) as count from item_feeds, item where item_feeds.item_id = item.id and item_feeds.feed_id = %d;",id).str );
        DBValue * count_v = cRes->FindByNameFirstRow( "count" );

        if ( (qcode&CODE_ZERO)==CODE_ZERO && count_v && count_v->getInt() ) 
            continue; // -z flag

        printf( id_fmt, v->getInt() );


        v = row.FindByName( "title" );
        const char * str = v->getString();
        int len = str ? strlen( str ) : 0;
        int utf8len = utf8strlen( str );
        if ( len == utf8len )
            printf( titlefmt, str ? str : "no title found" );
        else {
            str = utf8strncpy( str, rss_list_title_maxlen );
            buf = str;
            while ( utf8strlen(buf.str) < (signed)rss_list_title_maxlen ) {
                buf.append(" "); // pad out strings shorter than maxlen
            }
            printf( "%s  ", buf.str );
        }

        buf.erase();
        v = row.FindByName( "last_updated" );
        if ( v && v->getString() && strlen(v->getString()) > 0 ) {
            buf.strncpy( v->getString(), 10 );
            if ( buf.length() > 0 )
                printf( "%-4d  %-10s", count_v ? count_v->getInt() : -1, buf.str );
            else
                printf( "%-4d  %-10s", count_v ? count_v->getInt() : -1, "no dates" );
        } else {
            printf( "%-4d  %-10s", count_v ? count_v->getInt() : -1, "no dates" );
        }

        v = row.FindByName( "disabled" );
        if ( v && v->getInt() == 1 )
            printf( "  DISABLED " );
        else
            printf( "           " );

        v = row.FindByName( "type" );
        printf( " %6.6s", v && v->getString() ? v->getString() : "" );

        v = row.FindByName( "errmsg" );
        printf( " %s", v && v->getString() && strlen(v->getString())>0 ? v->getString() : "" );
        
        printf( "\n" );
    }
} // rss_list

static void rss_export_help() {
    turn_off_pager();
    printf( "usage: %s export [-m]\n\n    -m    minify output\n\n", exename.str );
}

// supports only 1 argument, -m 
void rss_export()
{
    bool minify = false;
    if ( cmd_args.length() ) {
        if ( *cmd_args[0] == "-h" || *cmd_args[0] == "--help" )
            return rss_export_help();
        if ( *cmd_args[0] != "-m" ) 
            return rss_export_help();
        minify = true;
    }

    XMLDocument doc;
    doc.InsertEndChild( doc.NewDeclaration() /* xml version="1.0" encoding="UTF-8" */ );

    XMLElement * opml = doc.NewElement( "opml" );
    doc.InsertEndChild( opml );
    opml->SetAttribute( "version", "1.0" );

    XMLElement * head = doc.NewElement( "head" );
    opml->InsertEndChild( head );
    XMLElement * title = doc.NewElement( "title" );
    XMLText * text = doc.NewText( RSS_OPML_TITLE_STRING ) ;
    title->InsertEndChild( text );
    head->InsertEndChild( title );

    XMLElement * body = doc.NewElement( "body" );
    opml->InsertEndChild( body );

#define OUTLINE_ATTRIB_SZ 7
    
    struct sixpack {
        basicString_t val[OUTLINE_ATTRIB_SZ];
        basicString_t& operator[] ( unsigned int i ) {
            return val[i];
        }
        void clear() { 
            for ( unsigned int i = 0 ; i < OUTLINE_ATTRIB_SZ; i++ ) { val[i].erase(); }
        }
    } six;

    const char * attr[] = { "text", "title", "type", "xmlUrl", "htmlUrl", "description", "disabled" };

    DBResult * res = DBA( "select * from feed;" );
    DBRow * row;
    while ( (row = res->NextRow()) )
    {
        six.clear();
        six[0] = __DontGetIfNotExist( "title", row );
        six[1] = __DontGetIfNotExist( "title", row );
        six[2] = __DontGetIfNotExist( "type", row );
        six[3] = __DontGetIfNotExist( "xmlUrl", row );
        six[4] = __DontGetIfNotExist( "htmlUrl", row );
        six[5] = __DontGetIfNotExist( "description", row );
    
        // dont know if I can get away with putting this here, but if I can then I can transport which feeds
        //  are disabled between installations of rss.
        six[6] = __DontGetIfNotExist( "disabled", row );
        if ( six[6] == "0" )
            six[6].clear(); // might as well not even print it

        //
        XMLElement * outline = doc.NewElement( "outline" );
        body->InsertEndChild( outline );

        for ( int i = 0 ; i < OUTLINE_ATTRIB_SZ ; i++ ) 
        {
            if ( six[i].length() ) {
                outline->SetAttribute( attr[i], six[i].str );
            }
        }
    }
#undef OUTLINE_ATTRIB_SZ

    if ( minify ) {
        XMLPrinter min_printer( stdout, true );
        doc.Print( &min_printer );
    } else {
        doc.Print();
    }
} // rss_export

static void rss_import_usage( const char *msg =0 )
{
    if ( msg )
        printf( "%s", msg );
    printf( "usage: '%s import <file>'\n", exename.str );
}

// 'rss import <file>' - import OPML file
void rss_import()
{
    basicString_t opml;
    XMLDocument doc;
    bool use_stdin = false;

    if ( check_cmdline( "-h" ) || check_cmdline( "--help" ) )
        return rss_import_usage("import takes 1 argument, or reads from stdin. ie. rss import < opml.xml\n" );

    if ( 0 == cmd_args.length() )
    {
        // check stdin
        if ( isatty(fileno(stdin)) || file_get_contents( "/dev/stdin", opml ) < 0 )
            return rss_import_usage("import takes 1 argument, or reads from stdin. ie. rss import < opml.xml.\n" );

        doc.Parse( opml.str, opml.length() );
        use_stdin = true;
    }
    else
    {
        opml = *cmd_args[0];
        printf( "loading: %s\n", opml.str );
        fflush(stdout);
        const char *fullpath = file_exists( opml.str );
        if ( !fullpath ) {
            error( "%s doesn't exist.\n", opml.str );
        }
        doc.LoadFile( opml.str );
        use_stdin = false;
    }


    FeedBuffer_t feedBuf;

    // Populates with array of URLs & titles from OPML 'outline' element, by recursively searching through the document
    scrapeOpml( doc.RootElement(), feedBuf );

    int num_inserted = 0;

    DBA.BeginTransaction();
        for ( unsigned int i = 0; i < feedBuf.count(); i++ ) 
        {
            if ( insert_feed_if_not_exist( *feedBuf[i] ) )
                ++num_inserted;
        }
    DBA.Commit();

    if ( !use_stdin ) {
        if ( 0 == num_inserted )
            printf( "no new feeds found in %s\n", opml.str );
        else
            printf( "%d new feeds added from %s\n", num_inserted, opml.str );
    }
} // rss_import

void remove_reports_over_quota()
{
    basicString_t mule;
    DBResult * res = DBA( "select id from reports order by update_time asc;" );
    if ( !res )
        return;

    for ( unsigned int i = 0 ; i < res->numRows() && res->numRows()-i >= max_reports_save; i++ )
    {
        DBRow& row = (*res)[i];
        DBValue * v = row.FindByName( "id" );
        if ( v ) 
            DBA( mule.sprintf("delete from reports where id = %d;",v->getInt()).str );
    }
}

void rss_update()
{
    if ( check_cmdline( "-h" ) || check_cmdline( "--help" ) ) {
        printf( "usage: %s update [matching parms]\n\n", exename.str );
        printf( "    where matching parms could be numeric or string\n    eg. 'rss update 10-15,16,20' or 'rss update hacker'\n    The latter would get all feeds with the word hacker in their title.\n    The former would get feeds with id 10 through 15, 16 and 20\n    With no arguments it updates all feeds.\n" );
        return;
    }

    basicString_t fetch( "select * from feed where (disabled = 0)" );
    basicString_t description;
    basicString_t last_updated;
    basicString_t matches;

    // group cmd_args together
    for ( unsigned int i = 0 ; i < cmd_args.count(); i++ ) 
        matches += *cmd_args[i] + " ";

    matches.trim();

    // this figures it out
    matches = translate_unknown_args( matches.str );

    if ( matches.length() ) 
        fetch.sprintf( "select * from feed where (disabled = 0) and %s;", matches.str );
    else
        fetch.append(";");


    DBResult * res = DBA( fetch.str );

    if ( !res || res->numRows() == 0 ) 
    {
        res = DBA( "select count(id) as c from feed;" );
        DBValue * v = res ? res->FindByNameFirstRow("c") : 0;
        if ( !v || v->getInt() == 0 )
            printf( "No feeds loaded. Use \"rss add\" or \"rss import\" to add feeds.\n" );
        else
            printf( "no feeds found matching %s. Possibly feed is disabled?\n", matches.str );
        return;
    }

    int feeds_altered = 0;
    int total_inserted = 0;
    stringbuffer_t updated_feeds;
    basicString_t ids_inserted;

    if ( res->numRows() > 0 ) 
        printf( "Updating your feeds:\n" );

    stimer_t timer;
    timer.set();

    unsigned int degree = ((unsigned int) log10( highest_feed_id() )) + 1;
    char url_fmt[ 16 ];

    // FIXME: a) if update_title_len = 0, then title length is not constrained;
    //        b) utf8len needed here with dynamic format to ensure justified columns
    sprintf( url_fmt, "%%-%dd %%-%u.%us", degree, update_title_len, update_title_len );

    // foreach feed
    for ( unsigned int i = 0; i < res->numRows(); i++ ) 
    {
        DBRow& row = (*res)[i];
        DBValue * val;

        // title, id from feeds-row
        val = row.FindByName( "title" );
        const char * title = !val ? "none" : val->getString() ? val->getString() : "none";
        val = row.FindByName( "id" );
        int feed_id = val ? val->getInt() : 0;
        
        // erase buffer before every fetch
        fetch.erase();
         
        // get the xmlurl 
        if ( (val = row.FindByName( "xmlUrl" )) ) {
            //printf( url_fmt, feed_id, val->getString() ); // URL
            printf( url_fmt, feed_id, title ); // TITLE
            fflush(stdout);

            //
            // FETCH FEED
            //
            if ( !get_url_with_curl( val->getString(), fetch ) ) {
                int to = 0;
                if ( fetch.length() == 0 ) {
                    to = update_timeouts_disable_if_needed( feed_id );
                }
                printf("\n");

                // put in report so we can see record of what's timing out
                basicString_t * str_p = new basicString_t;
                if ( to ) 
                    str_p->sprintf( " X- [%d] %s timed out %s time!11\n", feed_id, title, to > 9 ? "nth" : ordinals[to] );
                else
                    str_p->sprintf( " X- [%d] %s timed out!11\n", feed_id, title );
                updated_feeds.push_back( str_p );
                

                continue;
            }
        }


        // generate XML document from the html-fetch to get items
        XMLDocument document;
        document.Parse( fetch.str, fetch.length() );


        description = 0;
        last_updated = 0;
        int inserted_this_feed = 0;

        // this is used to signify that a feed is either 1=OK, or 0=in Error
        int feed_status = 0;


        //
        // INSERT ITEMS
        //
        inserted_this_feed = insert_any_new_items( document, feed_id, &feed_status, &ids_inserted );

        // feed_status 1 is OK
        if ( 1 == feed_status ) {
            // fetch successful, reset timeouts if needed
            reset_timeouts( feed_id );
        }


        // get description & pubDate from feed if we have it
        val = row.FindByName( "description" );

        // if feed doesn't already have a description (opml doesn't usually carry one)
        if ( !val || !val->getString() || strlen(val->getString())== 0 || strcmp(val->getString(),"(null)") == 0 ) 
        {
            // try rss
            XMLElement * elt = document.FirstChildElement( "rss" );
            if ( elt ) 
                elt = elt->FirstChildElement( "channel" );
            // try atom
            if ( !elt )
                elt = document.FirstChildElement( "feed" );
            // try rdf
            if ( !elt ) {
                elt = document.FirstChildElement( "rdf:RDF" );
                if ( elt ) 
                    elt = elt->FirstChildElement( "channel" );
            }

            if ( elt )
            {
                // possible kinds of description, ordered in terms of desirability
                const char * tries[] = { "description", "subtitle", "itunes:summary", "itunes:subtitle", 0 };
                const char **T = tries;
                do
                {
                    XMLElement * field = elt->FirstChildElement( *T );
                    if ( field ) {
                        XMLNode * goal = field->FirstChild();
                        if ( goal ) {
                            description = goal->Value();
                            DBA.fixQuotes( description );
                            break; // found; take first one
                        }
                    }
                }
                while ( *++T );
            }
        }

        // update counters and save a summary, if we got any
        if ( inserted_this_feed ) 
        {
            ++feeds_altered;
            basicString_t * str_p = new basicString_t;
            str_p->sprintf( "  * [%d] %s, %d item%c\n", feed_id, title, inserted_this_feed, inserted_this_feed>1?'s':' ' );
            updated_feeds.push_back( str_p );
            total_inserted += inserted_this_feed;
        }


        // get newest sqldate from items
        DBResult * result = DBA( fetch.sprintf( "select feed.last_updated,item.sqldate from item_feeds,feed,item where item_feeds.feed_id = feed.id and item_feeds.item_id = item.id and feed.id = %d order by item.sqldate desc limit 1;", feed_id ).str );
        if ( result ) {
            val = result->FindByNameFirstRow( "sqldate" );
            if ( val ) 
                last_updated = val->getString();
            val = result->FindByNameFirstRow( "last_updated" );
            if ( val && last_updated == val->getString() ) 
                last_updated = 0; // only bother to update if dates differ 
        }

        // report how many items directly, as your getting them
        if ( inserted_this_feed > 0 ) 
            printf( "  %d new item%s\n", inserted_this_feed, inserted_this_feed>1?"s":"" );
        else
            printf( "\n" );
        fflush(stdout);
        

        // set last_update to time of most recent post, and fix description if we dont have it and scraped one from the feed
        if ( (inserted_this_feed > 0 || feed_status == 1) && (description.length() > 0 || last_updated.length() > 0) )
        {
            basicString_t fmt;
            fetch = "update feed set ";
            if ( description.length() > 0 ) {
                fetch.append( "description = '" );
                fetch.append( description );
            }
            if ( last_updated.length() > 0 ) {
                if ( description.length() > 0 ) 
                    fetch.append("',");
                fetch.append( "last_updated = '" );
                fetch.append( last_updated );
            }
            DBA( fetch.append( fmt.sprintf( "' where id = %d;", feed_id ) ).str );
        }
    }

    // make summary
    fetch = "Got items from:\n";
    for ( unsigned int i = 0 ; i < updated_feeds.count(); i++ ) 
        fetch.append( updated_feeds[i]->str );
    if ( 0 == feeds_altered )
        matches.sprintf( "no new items found out of %u feed%s queried.", res->numRows(), res->numRows() > 1 ? "s" : "" );
    else
        matches.sprintf( "%d new item%s found for %d feed%s, out of %u feed%s queried.", total_inserted, total_inserted>1?"s":"", feeds_altered, feeds_altered > 1 ? "s" : "", res->numRows(), res->numRows() > 1 ? "s" : "" );
    fetch += matches;

    long long int sec = timer.delta();
    long long int min = sec / 60;
    sec %= 60;
    fetch += matches.sprintf( " Update took %ld:%02ld\n", min, sec );


    // print it
    printf( "%s", fetch.str );

    // save report
    remove_reports_over_quota();
    DBA.fixQuotes( fetch );
    basicString_t& range = translate_unknown_args( ids_inserted.str, "item.id" );
    DBA( matches.sprintf("insert into reports(update_time,report,item_ids) values ( '%s', '%s','%s');",sqldate_now(),fetch.str,range.str).str );
} // rss_update

static void rss_report_usage()
{
    printf( "usage: %s report [N|-a]\n\n", exename.str );
    printf( "\
    -a  print all reports\n \
    N   a number prints N reports into the past: eg. 2 would print the last two reports.\n" );
}

void rss_report()
{
    basicString_t query;
    int index = 0;

    if ( cmd_args.length() ) 
    {
        if ( *cmd_args[0] == "-h" || *cmd_args[0] == "--help" ) {
            rss_report_usage();
            exit( EXIT_SUCCESS );
        }

        index = atoi( cmd_args[0]->str );

        if ( *cmd_args[0] == "-a" ) 
            query = "select update_time,report from reports order by update_time desc;";
        else if ( 0 != index ) 
            query.sprintf( "select update_time,report from reports order by update_time desc limit %d;", index );
        else if ( cmd_args[0]->str[0] == '-' ) 
            return rss_report_usage(); // no other possible args start w/ -
        else
            query = "select update_time,report from reports order by update_time desc limit 1;";
    }
    else
        query = "select update_time,report from reports order by update_time desc limit 1;";


    // DO IT
    DBResult * res = DBA( query.str );

    if ( !res ) {
        printf( "no reports found\n" );
        return;
    }

    DBRow * row;
    int count = 0;
    while ( (row = res->NextRow()) )
    {
        if ( count++ )
            printf("\n");

        DBValue * v = row->FindByName( "update_time" );
        if ( !v ) {
            warning( "bad report\n" );
            return;
        }
        const char *date = v->getString();

        v = row->FindByName( "report" );
        if ( !v ) {
            warning( "bad report\n" );
            return;
        }
        printf( "%s", v->getString() );
        printf( "from update on %s\n", date );
    }
} // rss_report

static int rss_enable_disable()
{
    if ( cmd_args.length() < 2 ) 
        return printf( "usage: %s disable <-e|-d> <#>\n", exename.str );
    
    basicString_t &opt = *cmd_args[0];
    basicString_t &num = *cmd_args[1];

    if ( !opt.str || !num.str || (opt != "-e" && opt != "-d" ) )
        return printf( "usage: %s disable <-e|-d> <#>\n", exename.str );

    int feed_id = atoi( num.str );
    if ( 0 == feed_id )
        return printf( "usage: %s disable <-e|-d> <#>\n", exename.str );

    basicString_t buf;

    int dis = 0;
    if ( opt == "-d" )
        dis = 1;


    // check if it already is...
    DBResult * res = DBA( buf.sprintf("select disabled from feed where id = %d;",feed_id).str );
    if ( !res )
        return printf( "feed not found\n" );
    DBValue * v = res->FindByNameFirstRow( "disabled" );

    // always reset errmsg & timeouts on an enable call
    if ( 0 == dis )
        DBA( buf.sprintf( "update feed set timeouts = 0, errmsg = '' where id = %d;", feed_id ).str );

    if ( v && v->getInt() == dis ) 
        return printf( "feed %d already %s\n", feed_id, dis ? "disabled" : "enabled" );
        
    // do it
    DBA( buf.sprintf("update feed set disabled = %d where id = %d;", dis, feed_id).str );

    Feed_t & feed = feed_from_db( feed_id );
    printf( "Feed [%d] \"%s\" %s\n", feed_id, feed.title.str, feed.disabled?"disabled":"enabled again" );

    return 0;
}

// synonym for 'rss enable_disable -d'
int rss_disable()
{
    if ( cmd_args.count() != 1 )
        return printf( "usage: %s disable <feed id>\n", exename.str );

    int id = atoi( cmd_args[0]->str );
    if ( 0 == id )
        return printf( "usage: %s disable <feed id>\n", exename.str );

    // ok, we have the id, and know cmd_args has 1 <string *> in it,
    // we'll cheat by manipulating the args buffer and calling rss_disable.
    cmd_args.push_back( cmd_args[0]->str );
    *cmd_args[0] = "-d";
    return rss_enable_disable();
}

// synonym for 'rss enable_disable -e'
int rss_enable()
{
    if ( cmd_args.count() != 1 )
        return printf( "usage: %s enable <feed id>\n", exename.str );

    int id = atoi( cmd_args[0]->str );
    if ( 0 == id )
        return printf( "usage: %s enable <feed id>\n", exename.str );

    // ok, we have the id, and know cmd_args has 1 <string *> in it,
    // we'll cheat by manipulating the args buffer and calling rss_disable.
    cmd_args.push_back( cmd_args[0]->str );
    *cmd_args[0] = "-e";
    return rss_enable_disable();
}


static unsigned int _remove_feed( int feed_id )
{
    basicString_t query;

    DBA.BeginTransaction();

    // the feed
    DBA( query.sprintf( "delete from feed where id = %d;", feed_id ).str );

    // get set of item_id
    DBResult * res = DBA( query.sprintf( "select item.id from item,item_feeds where item_feeds.item_id = item.id and item_feeds.feed_id = %d;", feed_id ).str );

    // Reports actual # removed. May be intersection with another feed
    unsigned int items_removed = 0;

    // foreach item
    DBRow * row;
    while ( (row = res->NextRow()) ) 
    {
        DBValue * v = row->FindByName("id");
        int item_id;
        if ( v ) {
            item_id = v->getInt();

            // delete item_feed entry
            DBA( query.sprintf( "delete from item_feeds where item_id = %d and feed_id = %d;", item_id, feed_id ).str );

            // item may be part of another feed, lets check, if not remove it
            DBResult * check = DBA( query.sprintf( "select id from item_feeds where item_id = %d;", item_id ).str );
            if ( !check || check->numRows() == 0 ) {
                DBA( query.sprintf( "delete from item where id = %d;", item_id ).str );
                ++items_removed;
            }
        }
    }

    DBA.Commit();

    return items_removed;
}

static void rss_rm_usage( const char * msg =0 ) {
    if ( msg ) {
        printf( "%s", msg );
    }
    printf( "usage: %s rm [-q] <feed_id>\n\n", exename.str );
    printf( "    -q suppress terminal output (quiet) \n" );
}

void rss_rm()
{
    basicString_t match;
    bool quiet = false;

    if ( cmd_args.length() == 0 || cmd_args.length() > 2 )
        return rss_rm_usage();

    if ( check_cmdline( "-q" ) && cmd_args.length() < 2 )
        return rss_rm_usage();

    if ( check_cmdline( "-h" ) || check_cmdline( "--help" ) )
        return rss_rm_usage();

    if ( *cmd_args[0] == "-q" )
    {
        quiet = true;
        match = *cmd_args[1];
    }
    else if ( cmd_args.length() > 1 && *cmd_args[1] == "-q" )
    {
        quiet = true;
        match = *cmd_args[0];
    }
    else 
    {
        match = *cmd_args[0];
    }

    int id = atoi( match.str );
    if ( 0 == id )
        return rss_rm_usage( "id not found\n" );

    if ( quiet )
    {
        Feed_t & feed = feed_from_db( id );
        if ( feed.id == -1 )
            return;

        _remove_feed(feed.id);
    } 
    else
    {
        Feed_t & feed = feed_from_db( id );

        if ( feed.id == -1 ) {
            printf( "feed %d does not exist\n" , id );
            return;
        }

        printf( "Really delete [%d] \"%s\" [y/N]? ", id, feed.title.str );
        const char * ans = get_input();
        if ( ans && (strcmp( ans, "y" ) == 0 || strcmp( ans, "Y" ) == 0) ) 
        {
            unsigned int i_rm = _remove_feed( feed.id );
            printf( "removed feed %d, and %u item%s \n", id, i_rm, i_rm!=1?"s":"" );
        }
        else
            printf( "remove aborted\n" );
    }
}

static void rss_edit_usage( const char * msg =0 ) {
    if ( msg ) {
        printf( "%s", msg );
    }
    printf( "usage: %s edit <feed id> [[-t|-d|-x|-h|-m|-p] <arg>]\n", exename.str );
    printf( "    -t <arg>   set the title\n" );
    printf( "    -d <arg>   set the description\n" );
    printf( "    -x <arg>   set the xmlUrl\n" );
    printf( "    -h <arg>   set the htmlUrl\n" );
    printf( "    -m <arg>   set the type\n" );
    printf( "    -p <arg>   set the priority (default 5)\n" );
    printf( "    Use 'rss view <id>' to see feed attributes\n" );
}

void rss_edit()
{
    // must have feed id at least
    if ( cmd_args.count() < 1 )
        return rss_edit_usage( "must supply feed id\n" );

    // first argument must be a feed_id
    int feed_id = atoi( cmd_args[0]->str );
    if ( 0 == feed_id )
        return rss_edit_usage( "first argument is feed id\n" );

    Feed_t& feed = feed_from_db( feed_id );
    if ( -1 == feed.id )
        return rss_edit_usage( "feed does not exist\n" );


    basicString_t * S = cmd_args.count() > 1 ? cmd_args[1] : 0;
    basicString_t * A = cmd_args.count() > 2 ? cmd_args[2] : 0;
    const char * answer;
    basicString_t buf;
    const char * keyword;
    const char * current;


    if ( cmd_args.count() == 1 ) 
    {
        printf( "Editing: \"%s\".  What do you want to change?\n", feed.title.str );
        answer = prompt( " [1] title\n [2] description\n [3] xmlUrl\n [4] htmlUrl\n [5] type\n [6] priority\n (0 exits)>", 0 );
        int m = !answer || !*answer ? 6 : atoi ( answer );
        if ( m < 0 || m > 6 ) {
            printf( "edit aborted\n" );
            return;
        }
        S = &buf;
        buf.clear();
        switch ( m ) { 
        case 1: *S="-t";break; 
        case 2: *S="-d";break; 
        case 3: *S="-x";break; 
        case 4: *S="-h";break; 
        case 5: *S="-m";break;
        case 6: *S="-p";break;
        default:
            printf( "edit aborted\n" );
            return;
        }
    }

    if ( *S == "-t" )
    {
        keyword = "title";
        current = feed.title.str;
    }
    else if ( *S == "-d" )
    {
        keyword = "description";
        current = feed.description.str;
    }
    else if ( *S == "-x" )
    {
        keyword = "xmlUrl";
        current = feed.xmlUrl.str;
    }
    else if ( *S == "-h" )
    {
        keyword = "htmlUrl";
        current = feed.htmlUrl.str;
    } 
    else if ( *S == "-m" )
    {
        keyword = "type";
        current = feed.type.str;
    }    
    else if ( *S == "-p" )
    {
        keyword = "priority";
        current = feed.priority.str;
    }    
    else
    {
        return rss_edit_usage( "2nd argument is switch: -t, -d, -x, -h, -m, -p\n" );
    }    


    if ( ! A ) {
        printf( "current %s: \"%s\"\n", keyword, current );
        answer = prompt( buf.sprintf("new %s (0 cancels):",keyword).str, 0 );
    } else
        answer = A->str;

    if ( !answer || !*answer || *answer == '0' ) {
        printf( "%s unchanged\n", keyword );
        return;
    }

    basicString_t fixed = answer;
    DBA.fixQuotes( fixed );

    DBResult * res = DBA( buf.sprintf("update feed set %s = '%s' where id = %d;", keyword, fixed.str, feed_id).str );
    if ( !res || res->rowsUpdated() != 1 )
        printf( "update not completed successfully\n" );
    else
        printf( "[%d] \"%s\" %s set to \"%s\"\n", feed.id, feed.title.str, keyword, answer );
}

static void rss_search_usage( const char * msg =0 )
{
    turn_off_pager();
    if ( msg )
        printf( "%s\n", msg );
    printf( "usage: %s search [-o][-f id] [group of terms]\n\n", exename.str );
    printf( "   -o          changes to an \"OR\" clause instead of \"AND\"\n" );
    printf( "   -f <range>  limit search to feed(s). Can be expressed as 2,5,7-11\n" );
}

void rss_search()
{
    if ( cmd_args.length() == 0 )
        return rss_search_usage();

    if ( check_cmdline( "-h" ) || check_cmdline( "--help" ) )
        return rss_search_usage();

    bool OR = cmd_args[0]->icompare( "-o" );
    basicString_t specific_feeds;

    unsigned int match_start = 0;
    for ( unsigned int i = 0; i < cmd_args.count(); i++ ) {
        basicString_t & A = *cmd_args[i];
        if ( A == "-o" ) {
            OR = true;
            match_start = i+1;
        }
        else if ( A == "-f" ) {
            if ( i < cmd_args.count()-1 ) 
                specific_feeds = translate_unknown_args( cmd_args[++i]->str );
            else
                return rss_search_usage();
            match_start = i+1;
        }
    }


    basicString_t out;
    basicString_t fmt;
    basicString_t report;
    for ( unsigned int i = match_start; i < cmd_args.length(); i++ )
    {
        if ( out.length() )
            out += OR ? " or " : " and ";
        basicString_t& noquo = *cmd_args[i];
        DBA.fixQuotes( noquo );
        const char * m = noquo.str;
        out += fmt.sprintf( "(item.title like '%%%s%%' or item.description like '%%%s%%' or item.content like '%%%s%%' or item.author like '%%%s%%')", m, m, m, m );
        if ( report.length() )
            report += OR ? " or " : " and ";
        report += "\"";
        report += cmd_args[i]->str;
        report += "\"";
    }

    // show which feeds were searched specifically
    if ( specific_feeds.length() ) {
        DBResult * res = DBA( fmt.sprintf("select title from feed where %s;",specific_feeds.str).str );
        DBRow * r;
        bool skipit = false;
        fmt = " from: ";
        while ( (r = res->NextRow()) ) {
            DBValue * v = r->FindByName("title");
            if ( !v || !v->getString() )
                skipit = true;
            fmt += "\"";
            fmt += v->getString();
            fmt += "\", ";
        }
        if ( !skipit )
            report += fmt;
    }


    fmt = "select feed.title as ftitle, feed.id as feed_id, item.* from feed,item,item_feeds where feed.id=item_feeds.feed_id and item.id = item_feeds.item_id and (";
    fmt += out;
    if ( specific_feeds.length() ) {
        fmt += ") and (";
        fmt += specific_feeds;
    }
    fmt += ") order by sqldate desc;";

    DBResult * res = DBA( fmt.str ) ;

    if ( !res || res->numRows() == 0 ) {
        printf( "found no results matching %s\n", report.str );
        return;
    }

    draw_dashed_line();
    printf( "Found %u items matching: %s  -- sorting by most recent.\n", res->numRows(), report.str );
    draw_dashed_line();
    printf( "\n" );

    print_feed_items( res );

} // rss_search

// returns saved_items.id if successfully saved
int rss_mark( int feed_id, int item_id, const char *_title, const char *iurl, const char * murl =0 )
{
    if ( (!iurl || !*iurl) && (!murl || !*murl) )
        return 0;

    basicString_t title( _title );
    basicString_t item_url( iurl );
    basicString_t media_url( murl );
    basicString_t buf;
    basicString_t vals;
    basicString_t query;
    DBResult * res;

    DBA.fixQuotes( title );
    DBA.fixQuotes( item_url );
    DBA.fixQuotes( media_url );
    
    
    // check for duplicates
    query.sprintf( "select * from saved_links where feed_id = %d and title = '%s' and", feed_id, title.str );
    if ( item_url.length() ) 
        query += buf.sprintf( " item_url='%s' and", item_url.str );
    if ( media_url.length() ) 
        query += buf.sprintf( " media_url='%s' and", media_url.str );
    
    query.strncpy( query.str, query.length()-4 ); // clip trailing and
    query += ';';

    res = DBA( query.str );
    if ( res && res->numRows() > 0 ) // there is one
    {
        DBValue * v = res->FindByNameFirstRow( "downloaded" );
        int down = v ? v->getInt() : 0;

        if ( 0 == down ) {
            return 0; // have already and not downloaded yet
        }

        // if dupe has downloaded=1, set downloaded=0
        // saving again, reset downloaded
        v = res->FindByNameFirstRow( "id" );
        int id = v ? v->getInt() : 0;
        DBA( buf.sprintf( "update saved_links set downloaded = 0 where id = %d;", id ).str );
        return 1; // re-saved
    }


    // else if no matching item exists, add it
    query = "insert into saved_links(feed_id,item_id,timestamp,title," ;
    vals.sprintf( ") values (%d,%d,'%s','%s',", feed_id, item_id, sqldate_now(), title.str );

    if ( item_url.length() ) {
        query += "item_url,";
        vals += buf.sprintf( "'%s',", item_url.str );
    }
    if ( media_url.length() ) { 
        query += "media_url,";
        vals += buf.sprintf( "'%s',", media_url.str );
    }

    // clip commas
    query.strncpy( query.str, query.length()-1 ); 
    vals.strncpy( vals.str, vals.length()-1 );

    // concat
    query += vals += ");";

    // run
    res = DBA( query.str );
    if ( res ) 
        return res->lastInsertId();

    return 0;
}

void rss_pod()
{
    // scan media_url for podcast types
    const char ** pp = podcast_detection_types;
    basicString_t buf;
    basicString_t query( "select distinct feed.id,feed.title from feed,item_feeds,item where feed.id = item_feeds.feed_id and item_feeds.item_id = item.id and (" );
    do
    {
        if ( pp != podcast_detection_types )
            query += " or";
        query += buf.sprintf( " media_url like '%%%s%%'", *pp );
    } 
    while ( *++pp );
    query += ") order by feed.id asc;";

    DBResult * res = DBA( query.str );
    if ( !res )
        return;

    printf( "possible podcasts:\n" );

    DBRow * row;
    while ( (row = res->NextRow()) )
    {
        DBValue * v = row->FindByName( "id" );
        int id = v ? v->getInt() : 0;
        v = row->FindByName( "title" );
        printf( " [%d] %s\n", id, v ? v->getString() : "" );
    }
}

static void rss_vis_usage()
{
    printf( "usage: %s vis [-h|--help|-a|-n|-s|-f|-p|-b]\n\n", exename.str );
    printf( "    -n         show items from last update\n" );
    printf( "    -a <range> show all items. If range provided show only those in range.\n" );
    printf( "    -s <#>     skip ahead # items\n");
    printf( "    -f         show list of feeds\n" );
    printf( "    -p         show podcasts\n" );
    printf( "    -b         show bookmarks\n" );
    printf( "    *no args   show menu with more options\n" );
}

//
void rss_vis()
{
    if ( check_cmdline( "-h" ) || check_cmdline( "--help" ) )
        return rss_vis_usage();

    cursesMenu_t menu;

    // new items, skip ahead
    if ( check_cmdline( "-s" ) ) {
        if ( cmd_args.count() < 2 || *cmd_args[0] != "-s" )
            return rss_vis_usage();
        int skip = atoi( cmd_args[1]->str );
        menu.setAllItems( skip );
    }

    // all items sort by newest
    else if ( check_cmdline( "-a" ) ) {
        const char * constraint = cmdline_arg( "-a" );
        if ( constraint ) {
            // get list of feeds from cmdline and load only those feeds
            basicString_t &range = translate_unknown_args( constraint, "feed.id" );
            menu.setAllItems( range.str, constraint );
        } else {
            menu.setAllItems();
        }
    }

    // show items from last update
    else if ( check_cmdline( "-n" ) ) {
        menu.setLastUpdate();
    }

    // feeds
    else if ( check_cmdline( "-f" ) ) {
        menu.setFeedView();
    }

    // podcasts
    else if ( check_cmdline( "-p" ) ) {
        menu.setPodcasts();
    }

    // bookmarks
    else if ( check_cmdline( "-b" ) ) {
        menu.setBookmarks();
    }

    //
    // run it
    //
    menu.run();
}


void rss_priority() 
{
    DBResult * res = DBA( "select priority,id,title from feed order by priority desc;" );
    if ( !res )
        return;


    DBRow * row;
    while ( (row = res->NextRow()) )
    {
        DBValue * p = row->FindByName( "priority" );
        DBValue * i = row->FindByName( "id" );
        DBValue * t = row->FindByName( "title" );
        
        int pri = p ? p->getInt() : 0;
        int id = i ? i->getInt() : 0;
        const char * title = t ? t->getString() : 0;

        printf( "%-4d%-6d%s\n", pri, id, title );
    }
}


void rss_test()
{
#ifdef _DEBUG
    
    const char *ranges[] = { "", "10", "15,10,20,5,25", "12-18,4-8,1-3", "sterling", "NYT", ",11", "-22", " hacker ", 0 };
    const char **pp = ranges;
    while ( *pp ) {
        basicString_t& R = translate_unknown_args( *pp ); 
        printf( "%-20s", *pp );
        R.Print( "%s\n" );
        ++pp;
    }
    basicString_t& R = translate_unknown_args( "1-39,44,46-52,300-420", "item.id" ); 
    R.Print( "testing items: %s\n" );
    
    //------------------------------------
    basicString_t A( "melvin" );
    basicString_t B( "MELVIN" );
    if ( A.icompare( B ) ) 
        printf( "%s == %s\n", A.str, B.str );
    B.str[2] = 'i';
    if ( !A.icompare( B ) )
        printf( "%s != %s\n", A.str, B.str );

    // GET CONSOLE SIZE
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    printf ("term lines   %d\n", w.ws_row);
    printf ("term columns %d\n", w.ws_col);

    //rss_pod();


#else
    printf( "You found my secret test command!\n" );
#endif
}



// checks commands and calls appropriate 'rss_*' response function
void run_program_command()
{
    // start the pager for these commands only
    switch ( run_code )
    {
    //case CMD_FEEDS:
    //case CMD_REPORT:
    case CMD_LIST:
    {
        DBResult * res = DBA( "select count(id) as count from feed where disabled = 0;" );
        if ( res ) {
            DBValue * v = res->FindByNameFirstRow( "count" );
            if ( v && v->getInt() > term_lines )
                start_pager();
        }
        break;
    }
    case CMD_EXPORT:
    case CMD_DUMP:
    case CMD_SHOW:
    case CMD_SEARCH:
    case CMD_PRIORITY:
        start_pager();
        break;
    default:
        if ( force_pager )
            start_pager();
        break;
    }

    // run command
    switch ( run_code )
    {
    case CMD_IMPORT:
        rss_import(); 
        break;
    case CMD_EXPORT:
        rss_export();
        break;
    case CMD_LIST:
    case CMD_FEEDS:
        rss_list();
        break;
    case CMD_UPDATE:
        rss_update();
        break;
    case CMD_ADD:
        rss_add();
        break;
    case CMD_SHOW:
        rss_show();
        break;
    case CMD_DUMP:
        rss_dump();
        break;
    case CMD_REPORT:
        rss_report();
        break;
    case CMD_DISABLE:
        rss_disable();
        break;
    case CMD_ENABLE:
        rss_enable();
        break;
    case CMD_RM:
    case CMD_DEL:
        rss_rm();
        break;
    case CMD_EDIT:
        rss_edit();
        break;
    case CMD_VERSION:
        printf( "%s\n", RSS_VERSION_NUMBER );
        break;
    case CMD_VIEW:
        rss_view();
        break;
    case CMD_TEST:
        rss_test();
        break;
    case CMD_SEARCH:
        rss_search();
        break;
    case CMD_POD:
        rss_pod();
        break;
    case CMD_VIS:
        rss_vis();
        break;
    case CMD_PRIORITY:
        rss_priority();
        break;
    default:
        warning( "command not implemented yet\n" );
        exit( EXIT_SUCCESS );
    }
}


int main( int argc, char ** argv )
{
    // detect options, commands and arguments
    parse_arguments( argc, argv );

    // check db, check config, set paths
    setup_db_and_config();

    // ready to run sub-routine
    run_program_command();

    // In case we're in pager, don't wait to free old query results 
    DBA.nukeSavedResults();

    return 0;
}

